<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Battle - Race the AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Mobile optimizations */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
            overscroll-behavior: none;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stat-box {
            text-align: center;
            flex: 1;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-top: 5px;
        }

        .player-score {
            color: #4ade80;
        }

        .ai-score {
            color: #ff6b6b;
        }

        .canvas-container {
            position: relative;
            background: #1a1a2e;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            display: block;
            background: #0f0f1e;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .settings-toggle {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: 2px solid white;
            padding: 12px 25px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .settings-toggle:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        button {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .instructions {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 0.95em;
        }

        .setup-screen {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
        }

        .setup-options {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .setup-group {
            flex: 1;
            min-width: 200px;
        }

        .setup-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .setup-group select {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            cursor: pointer;
        }

        .controls-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .controls-info h3 {
            margin-bottom: 15px;
        }

        .controls-info p {
            margin: 8px 0;
            font-size: 1em;
        }

        .player-customization {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .player-card h4 {
            margin-bottom: 12px;
            font-size: 1.1em;
            color: #4ade80;
        }

        .player-card label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            opacity: 0.9;
        }

        .player-card select {
            width: 100%;
            padding: 8px;
            margin-bottom: 12px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 1em;
        }

        .color-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
        }

        .color-btn:hover:not(.disabled) {
            transform: scale(1.1);
        }

        .color-btn.selected {
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
        }

        .color-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-content h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .modal-content p {
            font-size: 1.3em;
            margin-bottom: 30px;
        }

        /* Mobile touch controls */
        .touch-controls {
            display: none;
            grid-template-columns: repeat(3, 70px);
            grid-template-rows: repeat(3, 70px);
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .touch-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 70px;
            min-height: 70px;
            touch-action: manipulation;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        .touch-btn.empty {
            visibility: hidden;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            canvas { width: 100%; height: auto; }
            .touch-controls { display: grid; }
        }

        @media (hover: none) and (pointer: coarse) {
            .touch-controls { display: grid; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üêç Snake Battle ‚öîÔ∏è</h1>

        <!-- Setup Screen -->
        <div id="setupScreen" class="setup-screen">
            <h2>üéÆ Game Setup</h2>
            <div class="setup-options">
                <div class="setup-group">
                    <label>Number of Players (Human):</label>
                    <select id="numPlayers" onchange="updatePlayerControls()">
                        <option value="1" selected>1 Player</option>
                        <option value="2">2 Players</option>
                        <option value="3">3 Players</option>
                        <option value="4">4 Players</option>
                    </select>
                </div>
                <div class="setup-group">
                    <label>Number of AI Bots:</label>
                    <select id="numBots">
                        <option value="0">0 Bots</option>
                        <option value="1" selected>1 Bot</option>
                        <option value="2">2 Bots</option>
                        <option value="3">3 Bots</option>
                    </select>
                </div>
            </div>
            <div id="playerCustomization" class="player-customization">
                <!-- Player cards will be dynamically generated here -->
            </div>
            <button onclick="startGameFromSetup()" style="margin-top: 20px; padding: 15px 40px; font-size: 1.2em;">üöÄ Start Battle!</button>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" style="display: none;">
            <div class="controls">
                <button class="settings-toggle" onclick="viewLeaderboard()">üèÜ Leaderboard</button>
                <button class="settings-toggle" onclick="toggleGameSettings()">‚öôÔ∏è Settings</button>
            </div>

            <div class="controls" style="margin-top: 0; margin-bottom: 20px;">
                <button onclick="startGame()">üîÑ New Game</button>
                <button onclick="surrenderGame()">üè≥Ô∏è Surrender</button>
                <button onclick="goHome()">üè† Home</button>
            </div>

            <div class="instructions" id="gameSettingsPanel" style="display: none; margin-bottom: 20px;">
                <h3 style="margin-bottom: 15px;">‚öôÔ∏è Settings</h3>
                <div style="text-align: center;">
                    <button id="soundToggle" onclick="toggleSound()" style="font-size: 2em; padding: 15px 30px; margin: 10px;">
                        üîä Sound On
                    </button>
                    <br>
                    <button onclick="backToSetup()" style="margin-top: 10px;">üîô Back to Setup</button>
                </div>
            </div>

            <div class="game-info" id="scoreBoard"></div>

            <div class="canvas-container">
                <canvas id="gameCanvas" width="600" height="600"></canvas>
            </div>

            <div class="instructions">
                <p>üçé Eat apples to grow and score points</p>
                <p>üíÄ Hit another snake's tail and you die - your score resets to 0!</p>
                <p>üéÅ Dead snakes drop special food (Golden üü† or Super üî¥)</p>
            </div>

            <!-- Touch controls for mobile -->
            <div class="touch-controls" id="touchControls">
                <div class="touch-btn empty"></div>
                <div class="touch-btn" ontouchstart="handleTouchControl('up')" onclick="handleTouchControl('up')">‚Üë</div>
                <div class="touch-btn empty"></div>
                <div class="touch-btn" ontouchstart="handleTouchControl('left')" onclick="handleTouchControl('left')">‚Üê</div>
                <div class="touch-btn empty"></div>
                <div class="touch-btn" ontouchstart="handleTouchControl('right')" onclick="handleTouchControl('right')">‚Üí</div>
                <div class="touch-btn empty"></div>
                <div class="touch-btn" ontouchstart="handleTouchControl('down')" onclick="handleTouchControl('down')">‚Üì</div>
                <div class="touch-btn empty"></div>
            </div>
        </div>
    </div>

    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="resultTitle">Game Over!</h2>
            <p id="resultMessage"></p>
            <div id="nameInputSection" style="margin: 20px 0; display: none;">
                <p style="margin-bottom: 10px;">üéâ New high score! Enter your name:</p>
                <input type="text" id="playerNameInput" maxlength="20" placeholder="Your name"
                    style="padding: 10px; font-size: 1em; border-radius: 5px; border: none; width: 80%; margin-bottom: 15px;">
            </div>
            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button onclick="closeModal()">Play Again</button>
                <button onclick="viewLeaderboard()">üèÜ Leaderboard</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const GRID_SIZE = 20;
        const TILE_COUNT = canvas.width / GRID_SIZE;

        // Audio System
        let audioContext = null;
        let soundEnabled = localStorage.getItem('snakeBattleSoundEnabled') !== 'false'; // Default to true
        let timerWarningPlayed = false;

        // Initialize Audio Context (mobile-compatible)
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        // Play a sound effect with specified parameters
        function playSound(type) {
            if (!soundEnabled) return;

            const ctx = initAudioContext();
            const now = ctx.currentTime;

            switch(type) {
                case 'food':
                    // Satisfying "nom" sound - quick frequency drop
                    playTone(ctx, now, 800, 600, 0.1, 'sine', 0.3);
                    break;

                case 'golden':
                    // Higher pitched, more exciting - ascending then descending
                    playTone(ctx, now, 1000, 1200, 0.05, 'sine', 0.25);
                    playTone(ctx, now + 0.05, 1200, 1000, 0.05, 'sine', 0.25);
                    playTone(ctx, now + 0.1, 1000, 1200, 0.05, 'sine', 0.25);
                    break;

                case 'super':
                    // Special power-up sound - rapid ascending tones
                    playTone(ctx, now, 600, 800, 0.06, 'square', 0.2);
                    playTone(ctx, now + 0.06, 800, 1000, 0.06, 'square', 0.2);
                    playTone(ctx, now + 0.12, 1000, 1400, 0.08, 'square', 0.2);
                    break;

                case 'death':
                    // Sad descending tone
                    playTone(ctx, now, 400, 200, 0.3, 'sawtooth', 0.3);
                    playTone(ctx, now + 0.15, 300, 150, 0.3, 'sawtooth', 0.25);
                    break;

                case 'win':
                    // Celebratory ascending sequence
                    playTone(ctx, now, 523, 523, 0.15, 'sine', 0.3);        // C
                    playTone(ctx, now + 0.15, 659, 659, 0.15, 'sine', 0.3); // E
                    playTone(ctx, now + 0.3, 784, 784, 0.15, 'sine', 0.3);  // G
                    playTone(ctx, now + 0.45, 1047, 1047, 0.3, 'sine', 0.4); // C (octave higher)
                    break;

                case 'warning':
                    // Urgent beep - pulsing
                    playTone(ctx, now, 880, 880, 0.1, 'square', 0.4);
                    playTone(ctx, now + 0.15, 880, 880, 0.1, 'square', 0.4);
                    playTone(ctx, now + 0.3, 880, 880, 0.15, 'square', 0.4);
                    break;
            }
        }

        // Helper function to play a single tone
        function playTone(ctx, startTime, startFreq, endFreq, duration, waveType, volume) {
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.type = waveType;
            oscillator.frequency.setValueAtTime(startFreq, startTime);
            oscillator.frequency.exponentialRampToValueAtTime(endFreq, startTime + duration);

            gainNode.gain.setValueAtTime(volume, startTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        // Toggle sound on/off
        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('snakeBattleSoundEnabled', soundEnabled);
            updateSoundButton();

            // Play a test sound when enabling
            if (soundEnabled) {
                playSound('food');
            }
        }

        // Update sound button appearance
        function updateSoundButton() {
            const btn = document.getElementById('soundToggle');
            if (btn) {
                btn.textContent = soundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
                btn.style.opacity = soundEnabled ? '1' : '0.7';
            }
        }

        // Game state
        let gameActive = false;
        let gameLoop = null;
        let numPlayers = 1;
        let numBots = 1;
        let snakes = []; // Array of all snakes (human + AI)
        let gameTimer = 60; // 60-second game timer
        let timerInterval = null;

        // Snake colors
        const SNAKE_COLORS = ['#4ade80', '#ff6b6b', '#fbbf24', '#a78bfa', '#60a5fa', '#f472b6', '#fb923c', '#34d399'];

        // Control scheme presets
        const CONTROL_PRESETS = {
            arrows: { name: '‚Üë‚Üì‚Üê‚Üí Arrow Keys', up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' },
            wasd: { name: 'WASD', up: 'w', down: 's', left: 'a', right: 'd' },
            ijkl: { name: 'IJKL', up: 'i', down: 'k', left: 'j', right: 'l' },
            numpad: { name: 'Numpad 8456', up: '8', down: '5', left: '4', right: '6' }
        };

        // Player customizations
        let playerSettings = [
            { controlScheme: 'arrows', color: SNAKE_COLORS[0] },
            { controlScheme: 'wasd', color: SNAKE_COLORS[1] },
            { controlScheme: 'ijkl', color: SNAKE_COLORS[2] },
            { controlScheme: 'numpad', color: SNAKE_COLORS[3] }
        ];

        // Control schemes for each player (will be set from playerSettings)
        const CONTROLS = {};

        // Apples
        let apples = [];

        // Special food types
        const FOOD_TYPES = {
            normal: { color: '#ffd93d', points: 1, growth: 1 },
            golden: { color: '#FFD700', points: 3, growth: 2 }, // Dropped when snake dies
            super: { color: '#FF6347', points: 5, growth: 3 }   // Rare drop
        };

        // Touch control handler for mobile
        function handleTouchControl(direction) {
            if (!gameActive || numPlayers === 0) return;

            const snake = snakes[0]; // Control Player 1 with touch
            if (!snake || snake.type === 'ai') return;

            switch(direction) {
                case 'up':
                    if (snake.dy !== 1) {
                        snake.nextDx = 0;
                        snake.nextDy = -1;
                    }
                    break;
                case 'down':
                    if (snake.dy !== -1) {
                        snake.nextDx = 0;
                        snake.nextDy = 1;
                    }
                    break;
                case 'left':
                    if (snake.dx !== 1) {
                        snake.nextDx = -1;
                        snake.nextDy = 0;
                    }
                    break;
                case 'right':
                    if (snake.dx !== -1) {
                        snake.nextDx = 1;
                        snake.nextDy = 0;
                    }
                    break;
            }
        }

        // Prevent context menu
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Input handling
        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;

            const key = e.key.toLowerCase();

            // Handle controls for each human player
            for (let i = 0; i < numPlayers; i++) {
                const snake = snakes[i];
                if (!snake || snake.type === 'ai') continue;

                const controls = CONTROLS[i];

                if ((key === controls.up.toLowerCase() || e.key === controls.up) && snake.dy !== 1) {
                    snake.nextDx = 0;
                    snake.nextDy = -1;
                }
                if ((key === controls.down.toLowerCase() || e.key === controls.down) && snake.dy !== -1) {
                    snake.nextDx = 0;
                    snake.nextDy = 1;
                }
                if ((key === controls.left.toLowerCase() || e.key === controls.left) && snake.dx !== 1) {
                    snake.nextDx = -1;
                    snake.nextDy = 0;
                }
                if ((key === controls.right.toLowerCase() || e.key === controls.right) && snake.dx !== -1) {
                    snake.nextDx = 1;
                    snake.nextDy = 0;
                }
            }
        });

        // Setup screen functions
        function updatePlayerControls() {
            numPlayers = parseInt(document.getElementById('numPlayers').value);
            const container = document.getElementById('playerCustomization');
            container.innerHTML = '';

            for (let i = 0; i < numPlayers; i++) {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.innerHTML = `
                    <h4>üéÆ Player ${i + 1}</h4>
                    <label>Controls:</label>
                    <select onchange="setPlayerControl(${i}, this.value)">
                        <option value="arrows" ${playerSettings[i].controlScheme === 'arrows' ? 'selected' : ''}>‚Üë‚Üì‚Üê‚Üí Arrow Keys</option>
                        <option value="wasd" ${playerSettings[i].controlScheme === 'wasd' ? 'selected' : ''}>WASD</option>
                        <option value="ijkl" ${playerSettings[i].controlScheme === 'ijkl' ? 'selected' : ''}>IJKL</option>
                        <option value="numpad" ${playerSettings[i].controlScheme === 'numpad' ? 'selected' : ''}>Numpad 8456</option>
                    </select>
                    <label>Snake Color:</label>
                    <div class="color-options" id="colorOptions${i}"></div>
                `;
                container.appendChild(card);

                // Add color buttons
                const colorOptions = document.getElementById(`colorOptions${i}`);
                SNAKE_COLORS.forEach((color, colorIndex) => {
                    const btn = document.createElement('div');
                    btn.className = 'color-btn';
                    btn.style.backgroundColor = color;
                    btn.onclick = () => setPlayerColor(i, color);
                    if (playerSettings[i].color === color) {
                        btn.classList.add('selected');
                    }
                    colorOptions.appendChild(btn);
                });
            }

            updateColorAvailability();
        }

        function setPlayerControl(playerIndex, scheme) {
            playerSettings[playerIndex].controlScheme = scheme;
        }

        function setPlayerColor(playerIndex, color) {
            // Check if color is already used by another player
            const usedByOther = playerSettings.some((setting, idx) =>
                idx !== playerIndex && setting.color === color && idx < numPlayers
            );

            if (usedByOther) {
                alert('This color is already in use by another player!');
                return;
            }

            playerSettings[playerIndex].color = color;
            updatePlayerControls();
        }

        function updateColorAvailability() {
            const usedColors = playerSettings.slice(0, numPlayers).map(s => s.color);

            for (let i = 0; i < numPlayers; i++) {
                const colorOptions = document.getElementById(`colorOptions${i}`);
                if (!colorOptions) continue;

                const buttons = colorOptions.querySelectorAll('.color-btn');
                buttons.forEach((btn) => {
                    const color = btn.style.backgroundColor;
                    const hexColor = rgbToHex(color);
                    const isUsed = usedColors.includes(hexColor) && hexColor !== playerSettings[i].color;

                    btn.classList.toggle('disabled', isUsed);
                    btn.classList.toggle('selected', hexColor === playerSettings[i].color);
                });
            }
        }

        function rgbToHex(rgb) {
            const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (!match) return rgb;
            return '#' + [match[1], match[2], match[3]].map(x => {
                const hex = parseInt(x).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        function startGameFromSetup() {
            numPlayers = parseInt(document.getElementById('numPlayers').value);
            numBots = parseInt(document.getElementById('numBots').value);

            const totalSnakes = numPlayers + numBots;
            if (totalSnakes < 1 || totalSnakes > 4) {
                alert('Total number of players and bots must be between 1 and 4!');
                return;
            }

            // Hide setup, show game
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';

            startGame();
        }

        function backToSetup() {
            if (gameActive && !confirm('Are you sure you want to quit the current game?')) {
                return;
            }

            gameActive = false;
            if (gameLoop) clearInterval(gameLoop);
            if (timerInterval) clearInterval(timerInterval);

            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('setupScreen').style.display = 'block';
        }

        function surrenderGame() {
            if (!gameActive) return;

            if (confirm('Are you sure you want to surrender? Your current scores will be recorded.')) {
                gameActive = false;
                if (gameLoop) clearInterval(gameLoop);
                if (timerInterval) clearInterval(timerInterval);

                // Find the highest scoring human player
                let highestHumanScore = 0;

                snakes.forEach(snake => {
                    if (snake.type === 'human' && snake.score > highestHumanScore) {
                        highestHumanScore = snake.score;
                    }
                });

                // Save to leaderboard if there's a score
                if (highestHumanScore > 0) {
                    saveToLeaderboard(highestHumanScore);
                }

                // Show scores for all players
                let message = 'Final Scores:\n\n';
                snakes.forEach(snake => {
                    message += `${snake.name}: ${snake.score} points\n`;
                });

                alert(message);
                backToSetup();
            }
        }

        function startGame() {
            gameActive = true;
            snakes = [];
            gameTimer = 60; // Reset timer to 60 seconds

            // Set up controls from player settings
            for (let i = 0; i < numPlayers; i++) {
                const preset = CONTROL_PRESETS[playerSettings[i].controlScheme];
                CONTROLS[i] = {
                    up: preset.up,
                    down: preset.down,
                    left: preset.left,
                    right: preset.right
                };
            }

            // Spawn positions (corners and center regions)
            const spawnPositions = [
                {x: 10, y: 10},
                {x: TILE_COUNT - 10, y: TILE_COUNT - 10},
                {x: 10, y: TILE_COUNT - 10},
                {x: TILE_COUNT - 10, y: 10}
            ];

            // Get available colors for bots (colors not used by players)
            const usedColors = playerSettings.slice(0, numPlayers).map(s => s.color);
            const availableColors = SNAKE_COLORS.filter(c => !usedColors.includes(c));

            // Create human player snakes
            for (let i = 0; i < numPlayers; i++) {
                snakes.push({
                    name: `Player ${i + 1}`,
                    type: 'human',
                    body: [{...spawnPositions[i]}],
                    dx: 1,
                    dy: 0,
                    nextDx: 1,
                    nextDy: 0,
                    score: 0,
                    color: playerSettings[i].color,
                    alive: true
                });
            }

            // Create AI bot snakes
            for (let i = 0; i < numBots; i++) {
                const snakeIndex = numPlayers + i;
                snakes.push({
                    name: `Bot ${i + 1}`,
                    type: 'ai',
                    body: [{...spawnPositions[snakeIndex]}],
                    dx: -1,
                    dy: 0,
                    nextDx: -1,
                    nextDy: 0,
                    score: 0,
                    color: availableColors[i] || SNAKE_COLORS[snakeIndex],
                    alive: true
                });
            }

            // Spawn initial apples
            apples = [];
            for (let i = 0; i < 5; i++) {
                spawnApple();
            }

            updateScoreboard();

            // Start game loop
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, 100);

            // Start timer countdown
            if (timerInterval) clearInterval(timerInterval);
            timerWarningPlayed = false; // Reset warning flag
            timerInterval = setInterval(() => {
                if (gameActive && gameTimer > 0) {
                    gameTimer--;
                    updateScoreboard();

                    // Play warning sound at 10 seconds
                    if (gameTimer === 10 && !timerWarningPlayed) {
                        playSound('warning');
                        timerWarningPlayed = true;
                    }

                    if (gameTimer === 0) {
                        endGame();
                    }
                }
            }, 1000);
        }

        function update() {
            if (!gameActive) return;

            // Update all snake directions and move them
            snakes.forEach((snake, index) => {
                if (!snake.alive) return;

                // Update direction
                snake.dx = snake.nextDx;
                snake.dy = snake.nextDy;

                // AI decision making
                if (snake.type === 'ai') {
                    updateAI(snake);
                }

                // Move snake
                moveSnake(snake);
            });

            // Check collisions between all snakes
            checkAllCollisions();

            // Check apple collisions
            checkAppleCollisions();

            // Draw everything
            draw();
        }

        function moveSnake(snake) {
            const head = {
                x: snake.body[0].x + snake.dx,
                y: snake.body[0].y + snake.dy
            };

            // Wrap around walls
            if (head.x < 0) head.x = TILE_COUNT - 1;
            if (head.x >= TILE_COUNT) head.x = 0;
            if (head.y < 0) head.y = TILE_COUNT - 1;
            if (head.y >= TILE_COUNT) head.y = 0;

            snake.body.unshift(head);
            snake.body.pop();
        }

        function updateAI(snake) {
            if (apples.length === 0) return;

            // Find nearest apple
            let nearestApple = apples[0];
            let minDist = Infinity;

            for (let apple of apples) {
                const dist = Math.abs(snake.body[0].x - apple.x) +
                            Math.abs(snake.body[0].y - apple.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearestApple = apple;
                }
            }

            // Simple AI: move towards nearest apple
            const dx = nearestApple.x - snake.body[0].x;
            const dy = nearestApple.y - snake.body[0].y;

            // AI makes more mistakes now (65% optimal instead of 80%)
            if (Math.random() > 0.35) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0 && snake.dx !== -1) {
                        snake.nextDx = 1;
                        snake.nextDy = 0;
                    } else if (dx < 0 && snake.dx !== 1) {
                        snake.nextDx = -1;
                        snake.nextDy = 0;
                    } else if (dy > 0 && snake.dy !== -1) {
                        snake.nextDx = 0;
                        snake.nextDy = 1;
                    } else if (dy < 0 && snake.dy !== 1) {
                        snake.nextDx = 0;
                        snake.nextDy = -1;
                    }
                } else {
                    if (dy > 0 && snake.dy !== -1) {
                        snake.nextDx = 0;
                        snake.nextDy = 1;
                    } else if (dy < 0 && snake.dy !== 1) {
                        snake.nextDx = 0;
                        snake.nextDy = -1;
                    } else if (dx > 0 && snake.dx !== -1) {
                        snake.nextDx = 1;
                        snake.nextDy = 0;
                    } else if (dx < 0 && snake.dx !== 1) {
                        snake.nextDx = -1;
                        snake.nextDy = 0;
                    }
                }
            }
        }

        function checkAllCollisions() {
            // Check each snake against all other snakes
            snakes.forEach((snake, index) => {
                if (!snake.alive) return;

                const head = snake.body[0];

                // Check collision with all other snakes' bodies
                snakes.forEach((otherSnake, otherIndex) => {
                    if (index === otherIndex || !otherSnake.alive) return;

                    // Check if this snake's head hits any part of the other snake's body
                    for (let segment of otherSnake.body) {
                        if (head.x === segment.x && head.y === segment.y) {
                            // Collision detected! Respawn this snake
                            respawnSnake(snake);
                            return;
                        }
                    }
                });
            });
        }

        function respawnSnake(snake) {
            // Play death sound
            playSound('death');

            // Spawn special food at death location
            spawnSpecialFood(snake.body[0].x, snake.body[0].y);

            // Reset score to 0 (not -1 like before)
            snake.score = 0;

            // Find a safe respawn position
            let newX, newY, safe;
            let attempts = 0;

            do {
                safe = true;
                newX = Math.floor(Math.random() * TILE_COUNT);
                newY = Math.floor(Math.random() * TILE_COUNT);

                // Make sure it's not too close to other snakes (at least 10 tiles away)
                for (let otherSnake of snakes) {
                    if (otherSnake === snake || !otherSnake.alive) continue;

                    const dist = Math.abs(newX - otherSnake.body[0].x) + Math.abs(newY - otherSnake.body[0].y);
                    if (dist < 10) {
                        safe = false;
                        break;
                    }

                    // Make sure it doesn't spawn on any other snake
                    for (let segment of otherSnake.body) {
                        if (segment.x === newX && segment.y === newY) {
                            safe = false;
                            break;
                        }
                    }
                    if (!safe) break;
                }

                attempts++;
            } while (!safe && attempts < 100);

            // Reset snake to new position (back to length 1)
            snake.body = [{x: newX, y: newY}];
            snake.dx = Math.random() > 0.5 ? 1 : -1;
            snake.dy = 0;
            snake.nextDx = snake.dx;
            snake.nextDy = snake.dy;

            updateScoreboard();
        }

        function spawnSpecialFood(x, y) {
            // 70% chance golden, 30% chance super
            const type = Math.random() < 0.7 ? 'golden' : 'super';

            apples.push({
                x: x,
                y: y,
                type: type
            });
        }

        function checkAppleCollisions() {
            // Check each snake for apple collisions
            snakes.forEach(snake => {
                if (!snake.alive) return;

                for (let i = apples.length - 1; i >= 0; i--) {
                    if (apples[i].x === snake.body[0].x &&
                        apples[i].y === snake.body[0].y) {
                        const apple = apples[i];
                        const foodType = FOOD_TYPES[apple.type || 'normal'];

                        snake.score += foodType.points;

                        // Grow snake based on food type
                        for (let j = 0; j < foodType.growth; j++) {
                            snake.body.push({...snake.body[snake.body.length - 1]});
                        }

                        // Play appropriate sound based on food type
                        if (apple.type === 'golden') {
                            playSound('golden');
                        } else if (apple.type === 'super') {
                            playSound('super');
                        } else {
                            playSound('food');
                        }

                        apples.splice(i, 1);

                        // Only spawn new apple if it was a normal one
                        if (!apple.type || apple.type === 'normal') {
                            spawnApple();
                        }

                        updateScoreboard();
                    }
                }
            });
        }

        function spawnApple() {
            let apple;
            let valid = false;

            while (!valid) {
                apple = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT),
                    type: 'normal'
                };

                valid = true;

                // Check collision with all snakes
                for (let snake of snakes) {
                    if (!snake.alive) continue;

                    for (let segment of snake.body) {
                        if (segment.x === apple.x && segment.y === apple.y) {
                            valid = false;
                            break;
                        }
                    }
                    if (!valid) break;
                }

                // Check collision with other apples
                if (valid) {
                    for (let other of apples) {
                        if (other.x === apple.x && other.y === apple.y) {
                            valid = false;
                            break;
                        }
                    }
                }
            }

            apples.push(apple);
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= TILE_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }

            // Draw apples
            for (let apple of apples) {
                const foodType = FOOD_TYPES[apple.type || 'normal'];
                const radius = apple.type === 'normal' ? GRID_SIZE / 2 - 2 : GRID_SIZE / 2;

                ctx.fillStyle = foodType.color;
                ctx.beginPath();
                ctx.arc(
                    apple.x * GRID_SIZE + GRID_SIZE / 2,
                    apple.y * GRID_SIZE + GRID_SIZE / 2,
                    radius,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Apple shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(
                    apple.x * GRID_SIZE + GRID_SIZE / 3,
                    apple.y * GRID_SIZE + GRID_SIZE / 3,
                    GRID_SIZE / 6,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Special indicator for golden/super food
                if (apple.type !== 'normal') {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(
                        apple.x * GRID_SIZE + GRID_SIZE / 2,
                        apple.y * GRID_SIZE + GRID_SIZE / 2,
                        radius + 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();
                }
            }

            // Draw all snakes
            snakes.forEach(snake => {
                if (snake.alive) {
                    drawSnake(snake);
                }
            });
        }

        function drawSnake(snake) {
            for (let i = 0; i < snake.body.length; i++) {
                const segment = snake.body[i];

                // Body
                ctx.fillStyle = snake.color;
                ctx.fillRect(
                    segment.x * GRID_SIZE + 1,
                    segment.y * GRID_SIZE + 1,
                    GRID_SIZE - 2,
                    GRID_SIZE - 2
                );

                // Head highlight
                if (i === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(
                        segment.x * GRID_SIZE + 3,
                        segment.y * GRID_SIZE + 3,
                        GRID_SIZE - 6,
                        GRID_SIZE - 6
                    );
                }
            }
        }

        function updateScoreboard() {
            const scoreBoard = document.getElementById('scoreBoard');
            scoreBoard.innerHTML = '';

            // Add timer display
            const timerBox = document.createElement('div');
            timerBox.className = 'stat-box';
            timerBox.innerHTML = `
                <div class="stat-label">‚è±Ô∏è Time</div>
                <div class="stat-value" style="color: ${gameTimer <= 10 ? '#ff6b6b' : '#ffd93d'}">${gameTimer}s</div>
            `;
            scoreBoard.appendChild(timerBox);

            snakes.forEach(snake => {
                const statBox = document.createElement('div');
                statBox.className = 'stat-box';
                statBox.innerHTML = `
                    <div class="stat-label" style="color: ${snake.color}">${snake.name}</div>
                    <div class="stat-value" style="color: ${snake.color}">${snake.score}</div>
                `;
                scoreBoard.appendChild(statBox);
            });
        }

        function endGame() {
            gameActive = false;
            if (gameLoop) clearInterval(gameLoop);
            if (timerInterval) clearInterval(timerInterval);

            // Play win sound
            playSound('win');

            // Find the highest scoring human player
            let highestHumanScore = 0;
            let winningPlayer = null;

            snakes.forEach(snake => {
                if (snake.type === 'human' && snake.score > highestHumanScore) {
                    highestHumanScore = snake.score;
                    winningPlayer = snake;
                }
            });

            // Display results
            const modal = document.getElementById('gameOverModal');
            const resultTitle = document.getElementById('resultTitle');
            const resultMessage = document.getElementById('resultMessage');
            const nameInputSection = document.getElementById('nameInputSection');

            resultTitle.textContent = 'Time\'s Up!';

            // Build results message
            let message = 'Final Scores:\n\n';
            snakes.forEach(snake => {
                message += `${snake.name}: ${snake.score} points\n`;
            });

            resultMessage.textContent = message;
            resultMessage.style.whiteSpace = 'pre-line';

            // Check if we should save to leaderboard (only for human players with score > 0)
            if (highestHumanScore > 0) {
                saveToLeaderboard(highestHumanScore);

                // Show name input if it's a new entry
                const playerName = localStorage.getItem('playerName');
                if (!playerName) {
                    nameInputSection.style.display = 'block';
                } else {
                    nameInputSection.style.display = 'none';
                }
            } else {
                nameInputSection.style.display = 'none';
            }

            modal.classList.add('active');
        }

        function saveToLeaderboard(score) {
            // Get or prompt for player name
            let playerName = localStorage.getItem('playerName');

            // If name input is visible, get the value from there
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput.value.trim()) {
                playerName = nameInput.value.trim();
                localStorage.setItem('playerName', playerName);
            } else if (!playerName) {
                // If no name stored and input is empty, use default
                playerName = 'Anonymous';
            }

            // Create score entry
            const scoreEntry = {
                name: playerName,
                score: score,
                date: new Date().toISOString()
            };

            // Get existing scores
            let scores = [];
            try {
                const storedScores = localStorage.getItem('snakeBattleScores');
                if (storedScores) {
                    scores = JSON.parse(storedScores);
                }
            } catch (e) {
                console.error('Error loading scores:', e);
                scores = [];
            }

            // Add new score
            scores.push(scoreEntry);

            // Sort by score (descending)
            scores.sort((a, b) => b.score - a.score);

            // Keep only top 100
            scores = scores.slice(0, 100);

            // Save back to localStorage
            try {
                localStorage.setItem('snakeBattleScores', JSON.stringify(scores));
            } catch (e) {
                console.error('Error saving scores:', e);
            }
        }

        function closeModal() {
            // Save name if provided in the input
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput.value.trim()) {
                localStorage.setItem('playerName', nameInput.value.trim());
            }

            const modal = document.getElementById('gameOverModal');
            modal.classList.remove('active');
            nameInput.value = ''; // Clear input for next time

            // Return to setup screen
            backToSetup();
        }

        function viewLeaderboard() {
            window.location.href = 'leaderboard.html';
        }

        function goHome() {
            window.location.href = 'index.html';
        }

        function toggleGameSettings() {
            const panel = document.getElementById('gameSettingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        // Initialize sound button and player customization on page load
        window.addEventListener('DOMContentLoaded', () => {
            updateSoundButton();
            updatePlayerControls();
        });

        // Initial draw
        draw();
    </script>
</body>
</html>
