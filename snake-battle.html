<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Battle - Ultimate Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
            overflow-x: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
        }

        .stat-box {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .stat-label {
            font-size: 0.85em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .player-score { color: #4ade80; }
        .ai-score { color: #ff6b6b; }
        .time-warning { color: #ffa500; animation: pulse 0.5s infinite; }
        .time-critical { color: #ff4444; animation: pulse 0.3s infinite; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .power-ups-display {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
            min-height: 50px;
        }

        .active-powerup {
            background: rgba(255, 215, 0, 0.3);
            border: 2px solid gold;
            border-radius: 10px;
            padding: 8px 15px;
            font-size: 1.2em;
            animation: glow 1s infinite;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        .canvas-wrapper {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #1a1a2e;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            display: block;
            background: #0f0f1e;
        }

        .minimap-container {
            width: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
        }

        .minimap-title {
            text-align: center;
            font-size: 0.8em;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        #minimap {
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            width: 100%;
            height: 130px;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        button {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 0.95em;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-content h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .modal-content p {
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .mode-selection, .difficulty-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .mode-btn, .difficulty-btn {
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            color: white;
        }

        .mode-btn:hover, .difficulty-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .mode-btn.selected, .difficulty-btn.selected {
            background: rgba(255, 215, 0, 0.3);
            border-color: gold;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
            text-align: left;
            font-size: 0.95em;
        }

        .pause-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 10px;
        }

        .pause-overlay.active {
            display: flex;
        }

        .pause-menu {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
        }

        .pause-menu h2 {
            margin-bottom: 20px;
        }

        .pause-menu button {
            margin: 5px;
        }

        .score-popup {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: gold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            animation: scoreFloat 1s ease-out forwards;
        }

        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* Home Button */
        .home-button {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            text-decoration: none;
            border-radius: 10px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10000;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 16px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .home-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        /* Mobile D-Pad Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
        }

        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
        }

        .dpad-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #667eea;
            border-radius: 10px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            transition: all 0.2s;
        }

        .dpad-btn:active {
            background: rgba(102, 126, 234, 0.8);
            transform: scale(0.95);
        }

        .dpad-up { grid-column: 2; grid-row: 1; }
        .dpad-left { grid-column: 1; grid-row: 2; }
        .dpad-down { grid-column: 2; grid-row: 3; }
        .dpad-right { grid-column: 3; grid-row: 2; }

        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .canvas-wrapper { flex-direction: column; }
            .minimap-container { width: 100%; }
            #minimap { height: 150px; }
            .mobile-controls { display: block; }
            .home-button {
                top: 10px;
                left: 10px;
                padding: 10px 16px;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .dpad {
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
            }
            .dpad-btn {
                font-size: 20px;
            }
        }

        /* Prevent text selection and context menu */
        canvas, button, .home-button, .dpad-btn {
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
    </style>
</head>
<body>
    <a href="index.html" class="home-button">üè† Home</a>
    <div class="game-container">
        <h1>üêç Snake Battle - Ultimate Edition ‚öîÔ∏è</h1>

        <div class="game-info">
            <div class="stat-box">
                <div class="stat-label">‚è∞ Time</div>
                <div class="stat-value" id="timeDisplay">60</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">üü¢ Your Score</div>
                <div class="stat-value player-score" id="playerScore">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">üî¥ AI Score</div>
                <div class="stat-value ai-score" id="aiScore">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">üéØ Mode</div>
                <div class="stat-value" id="modeDisplay" style="font-size: 1em;">-</div>
            </div>
        </div>

        <div class="power-ups-display" id="powerupsDisplay"></div>

        <div class="canvas-wrapper">
            <div class="canvas-container">
                <canvas id="gameCanvas" width="600" height="600"></canvas>
                <div class="pause-overlay" id="pauseOverlay">
                    <div class="pause-menu">
                        <h2>‚è∏Ô∏è PAUSED</h2>
                        <button onclick="resumeGame()">Resume</button>
                        <button onclick="restartGame()">Restart</button>
                        <button onclick="mainMenu()">Main Menu</button>
                    </div>
                </div>
            </div>
            <div class="minimap-container">
                <div class="minimap-title">üìç Minimap</div>
                <canvas id="minimap"></canvas>
            </div>
        </div>

        <div class="controls">
            <button onclick="showModeSelection()">üéÆ Start Game</button>
            <button onclick="toggleSound()" id="soundBtn">üîä Sound ON</button>
            <button onclick="goHome()">üè† Home</button>
        </div>

        <div class="instructions">
            <p>üéØ Arrow Keys / WASD to move ‚Ä¢ ESC to pause ‚Ä¢ Collect power-ups and apples!</p>
            <p style="margin-top: 10px;">üì± On mobile: Use D-pad or swipe to control snake</p>
        </div>
    </div>

    <!-- Mobile D-Pad Controls -->
    <div class="mobile-controls">
        <div class="dpad">
            <button class="dpad-btn dpad-up" id="dpadUp">‚ñ≤</button>
            <button class="dpad-btn dpad-left" id="dpadLeft">‚óÑ</button>
            <button class="dpad-btn dpad-down" id="dpadDown">‚ñº</button>
            <button class="dpad-btn dpad-right" id="dpadRight">‚ñ∫</button>
        </div>
    </div>

    <!-- Mode Selection Modal -->
    <div class="modal" id="modeSelectionModal">
        <div class="modal-content">
            <h2>üéÆ Select Game Mode</h2>
            <div class="mode-selection">
                <button class="mode-btn" onclick="selectMode('timeAttack')">
                    <div style="font-size: 2em;">‚è±Ô∏è</div>
                    <div><strong>Time Attack</strong></div>
                    <div style="font-size: 0.85em;">60 seconds battle</div>
                </button>
                <button class="mode-btn" onclick="selectMode('survival')">
                    <div style="font-size: 2em;">üíÄ</div>
                    <div><strong>Survival</strong></div>
                    <div style="font-size: 0.85em;">Last as long as you can</div>
                </button>
                <button class="mode-btn" onclick="selectMode('scoreRace')">
                    <div style="font-size: 2em;">üèÜ</div>
                    <div><strong>Score Race</strong></div>
                    <div style="font-size: 0.85em;">First to 50 points</div>
                </button>
                <button class="mode-btn" onclick="selectMode('endless')">
                    <div style="font-size: 2em;">‚ôæÔ∏è</div>
                    <div><strong>Endless</strong></div>
                    <div style="font-size: 0.85em;">Infinite highscore mode</div>
                </button>
            </div>
        </div>
    </div>

    <!-- Difficulty Selection Modal -->
    <div class="modal" id="difficultyModal">
        <div class="modal-content">
            <h2>‚öôÔ∏è Select Difficulty</h2>
            <div class="difficulty-selection">
                <button class="difficulty-btn" onclick="selectDifficulty('easy')">
                    <div style="font-size: 2em;">üòä</div>
                    <div><strong>Easy</strong></div>
                    <div style="font-size: 0.85em;">Slower pace, fewer obstacles</div>
                </button>
                <button class="difficulty-btn" onclick="selectDifficulty('normal')">
                    <div style="font-size: 2em;">üòê</div>
                    <div><strong>Normal</strong></div>
                    <div style="font-size: 0.85em;">Balanced gameplay</div>
                </button>
                <button class="difficulty-btn" onclick="selectDifficulty('hard')">
                    <div style="font-size: 2em;">üò∞</div>
                    <div><strong>Hard</strong></div>
                    <div style="font-size: 0.85em;">Faster, smarter AI</div>
                </button>
                <button class="difficulty-btn" onclick="selectDifficulty('insane')">
                    <div style="font-size: 2em;">üíÄ</div>
                    <div><strong>Insane</strong></div>
                    <div style="font-size: 0.85em;">Ultimate challenge!</div>
                </button>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="resultTitle">Game Over!</h2>
            <p id="resultMessage"></p>
            <div class="stats-grid" id="statsGrid"></div>
            <div>
                <button onclick="restartGame()">Play Again</button>
                <button onclick="mainMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        // Game constants
        const GRID_SIZE = 20;
        const TILE_COUNT = canvas.width / GRID_SIZE;

        // Game state
        let gameActive = false;
        let gamePaused = false;
        let timeRemaining = 60;
        let playerScore = 0;
        let aiScore = 0;
        let gameLoop = null;
        let timerInterval = null;
        let gameMode = 'timeAttack';
        let difficulty = 'normal';
        let soundEnabled = true;
        let highScore = parseInt(localStorage.getItem('snakeBattleHighScore') || '0');
        let totalApplesEaten = 0;
        let totalPowerupsCollected = 0;
        let gameStartTime = 0;

        // Difficulty settings
        const difficultySettings = {
            easy: { speed: 150, aiAccuracy: 0.5, obstacleCount: 3, powerupChance: 0.015 },
            normal: { speed: 100, aiAccuracy: 0.7, obstacleCount: 5, powerupChance: 0.01 },
            hard: { speed: 70, aiAccuracy: 0.85, obstacleCount: 7, powerupChance: 0.008 },
            insane: { speed: 50, aiAccuracy: 0.95, obstacleCount: 10, powerupChance: 0.006 }
        };

        // Snakes
        let playerSnake = {
            body: [{x: 10, y: 10}],
            dx: 0, dy: 0,
            nextDx: 0, nextDy: 0,
            color: '#4ade80',
            powerups: {},
            trail: []
        };

        let aiSnake = {
            body: [{x: 20, y: 20}],
            dx: 0, dy: 0,
            color: '#ff6b6b',
            powerups: {},
            trail: []
        };

        // Game objects
        let apples = [];
        let powerups = [];
        let obstacles = [];
        let particles = [];
        let scorePopups = [];
        let shrinkZone = null;

        // Power-up types
        const POWERUP_TYPES = {
            speed: { emoji: '‚ö°', name: 'Speed Boost', duration: 5000, color: '#ffd93d' },
            slow: { emoji: 'üêå', name: 'Slow Motion', duration: 5000, color: '#90EE90' },
            magnet: { emoji: 'üß≤', name: 'Magnet', duration: 8000, color: '#FF69B4' },
            shield: { emoji: 'üõ°Ô∏è', name: 'Shield', duration: 5000, color: '#87CEEB' },
            doublePoints: { emoji: '‚≠ê', name: 'Double Points', duration: 10000, color: '#FFD700' },
            shrink: { emoji: 'üìè', name: 'Shrink', duration: 0, color: '#FF6347' }
        };

        // Audio Context
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // Sound effects
        function playSound(frequency, duration, type = 'sine') {
            if (!soundEnabled) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function playEatSound() {
            playSound(800, 0.1);
            setTimeout(() => playSound(1000, 0.1), 50);
        }

        function playPowerupSound() {
            playSound(600, 0.1);
            setTimeout(() => playSound(800, 0.1), 50);
            setTimeout(() => playSound(1000, 0.1), 100);
        }

        function playCollisionSound() {
            playSound(100, 0.3, 'sawtooth');
        }

        function playVictorySound() {
            playSound(500, 0.15);
            setTimeout(() => playSound(600, 0.15), 100);
            setTimeout(() => playSound(800, 0.3), 200);
        }

        function playDefeatSound() {
            playSound(400, 0.15);
            setTimeout(() => playSound(300, 0.15), 100);
            setTimeout(() => playSound(200, 0.3), 200);
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? 'üîä Sound ON' : 'üîá Sound OFF';
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (gameActive) togglePause();
                return;
            }

            if (!gameActive || gamePaused) return;

            if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') && playerSnake.dy !== 1) {
                playerSnake.nextDx = 0; playerSnake.nextDy = -1;
            }
            if ((e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') && playerSnake.dy !== -1) {
                playerSnake.nextDx = 0; playerSnake.nextDy = 1;
            }
            if ((e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') && playerSnake.dx !== 1) {
                playerSnake.nextDx = -1; playerSnake.nextDy = 0;
            }
            if ((e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') && playerSnake.dx !== -1) {
                playerSnake.nextDx = 1; playerSnake.nextDy = 0;
            }
        });

        function showModeSelection() {
            document.getElementById('modeSelectionModal').classList.add('active');
        }

        function selectMode(mode) {
            gameMode = mode;
            document.getElementById('modeSelectionModal').classList.remove('active');
            document.getElementById('difficultyModal').classList.add('active');
        }

        function selectDifficulty(diff) {
            difficulty = diff;
            document.getElementById('difficultyModal').classList.remove('active');
            startGame();
        }

        function mainMenu() {
            document.getElementById('gameOverModal').classList.remove('active');
            document.getElementById('pauseOverlay').classList.remove('active');
            gamePaused = false;
            showModeSelection();
        }

        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pauseOverlay').classList.toggle('active');
        }

        function resumeGame() {
            gamePaused = false;
            document.getElementById('pauseOverlay').classList.remove('active');
        }

        function restartGame() {
            document.getElementById('gameOverModal').classList.remove('active');
            document.getElementById('pauseOverlay').classList.remove('active');
            gamePaused = false;
            startGame();
        }

        function startGame() {
            gameActive = true;
            gamePaused = false;
            gameStartTime = Date.now();
            totalApplesEaten = 0;
            totalPowerupsCollected = 0;

            // Set time based on mode
            if (gameMode === 'timeAttack') {
                timeRemaining = 60;
            } else if (gameMode === 'survival') {
                timeRemaining = 0;
            } else if (gameMode === 'scoreRace' || gameMode === 'endless') {
                timeRemaining = 0;
            }

            playerScore = 0;
            aiScore = 0;

            // Reset snakes
            playerSnake = {
                body: [{x: 10, y: 10}],
                dx: 1, dy: 0,
                nextDx: 1, nextDy: 0,
                color: '#4ade80',
                powerups: {},
                trail: []
            };

            aiSnake = {
                body: [{x: 20, y: 20}],
                dx: -1, dy: 0,
                color: '#ff6b6b',
                powerups: {},
                trail: []
            };

            // Reset game objects
            apples = [];
            powerups = [];
            obstacles = [];
            particles = [];
            scorePopups = [];
            shrinkZone = null;

            // Spawn initial apples
            for (let i = 0; i < 5; i++) {
                spawnApple();
            }

            // Spawn obstacles
            const settings = difficultySettings[difficulty];
            for (let i = 0; i < settings.obstacleCount; i++) {
                spawnObstacle();
            }

            updateDisplay();
            updateModeDisplay();

            // Start game loop
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, settings.speed);

            // Start timer
            if (timerInterval) clearInterval(timerInterval);
            if (gameMode === 'timeAttack') {
                timerInterval = setInterval(updateTimer, 1000);
            } else if (gameMode === 'survival' || gameMode === 'scoreRace' || gameMode === 'endless') {
                timerInterval = setInterval(() => {
                    timeRemaining++;
                    updateDisplay();
                }, 1000);
            }
        }

        function update() {
            if (!gameActive || gamePaused) return;

            // Update player direction
            playerSnake.dx = playerSnake.nextDx;
            playerSnake.dy = playerSnake.nextDy;

            // Move snakes
            const playerSpeed = playerSnake.powerups.speed ? 2 : 1;
            const aiSpeed = aiSnake.powerups.slow ? 0.5 : 1;

            for (let i = 0; i < playerSpeed; i++) {
                moveSnake(playerSnake);
                addTrail(playerSnake);
            }

            if (Math.random() < aiSpeed) {
                updateAI();
                moveSnake(aiSnake);
                addTrail(aiSnake);
            }

            // Update moving obstacles
            updateObstacles();

            // Check collisions
            if (checkCollisions()) return;

            // Check apple collisions
            checkAppleCollisions();

            // Check powerup collisions
            checkPowerupCollisions();

            // Spawn powerups randomly
            const settings = difficultySettings[difficulty];
            if (Math.random() < settings.powerupChance) {
                spawnPowerup();
            }

            // Update powerups
            updatePowerups();

            // Update particles
            updateParticles();

            // Update score popups
            updateScorePopups();

            // Shrink zone in survival mode
            if (gameMode === 'survival' && timeRemaining > 30 && timeRemaining % 15 === 0) {
                updateShrinkZone();
            }

            // Draw everything
            draw();
            drawMinimap();
        }

        function moveSnake(snake) {
            const head = {
                x: snake.body[0].x + snake.dx,
                y: snake.body[0].y + snake.dy
            };

            // Wrap around or die based on mode
            if (gameMode === 'survival' && shrinkZone) {
                if (head.x < shrinkZone.left || head.x >= shrinkZone.right ||
                    head.y < shrinkZone.top || head.y >= shrinkZone.bottom) {
                    if (snake === playerSnake) {
                        endGame('You hit the boundary!');
                    }
                    return;
                }
            } else {
                if (head.x < 0) head.x = TILE_COUNT - 1;
                if (head.x >= TILE_COUNT) head.x = 0;
                if (head.y < 0) head.y = TILE_COUNT - 1;
                if (head.y >= TILE_COUNT) head.y = 0;
            }

            snake.body.unshift(head);
            snake.body.pop();
        }

        function addTrail(snake) {
            if (snake.body.length > 0) {
                snake.trail.push({
                    x: snake.body[0].x * GRID_SIZE + GRID_SIZE / 2,
                    y: snake.body[0].y * GRID_SIZE + GRID_SIZE / 2,
                    life: 1
                });
                if (snake.trail.length > 20) {
                    snake.trail.shift();
                }
            }
        }

        function updateAI() {
            if (apples.length === 0) return;

            const settings = difficultySettings[difficulty];

            // Find target (apple or powerup)
            let target = null;

            // Sometimes chase powerups
            if (powerups.length > 0 && Math.random() < settings.aiAccuracy) {
                target = findNearestItem(aiSnake.body[0], powerups);
            }

            if (!target) {
                target = findNearestItem(aiSnake.body[0], apples);
            }

            if (!target) return;

            // Use A* pathfinding for hard and insane
            if (difficulty === 'hard' || difficulty === 'insane') {
                const path = aStarPathfinding(aiSnake.body[0], target);
                if (path && path.length > 1) {
                    const next = path[1];
                    const dx = next.x - aiSnake.body[0].x;
                    const dy = next.y - aiSnake.body[0].y;

                    if (dx !== 0 && aiSnake.dx !== -dx) {
                        aiSnake.dx = dx;
                        aiSnake.dy = 0;
                    } else if (dy !== 0 && aiSnake.dy !== -dy) {
                        aiSnake.dx = 0;
                        aiSnake.dy = dy;
                    }
                }
            } else {
                // Simple pathfinding for easy/normal
                const dx = target.x - aiSnake.body[0].x;
                const dy = target.y - aiSnake.body[0].y;

                if (Math.random() < settings.aiAccuracy) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 0 && aiSnake.dx !== -1) {
                            aiSnake.dx = 1; aiSnake.dy = 0;
                        } else if (dx < 0 && aiSnake.dx !== 1) {
                            aiSnake.dx = -1; aiSnake.dy = 0;
                        }
                    } else {
                        if (dy > 0 && aiSnake.dy !== -1) {
                            aiSnake.dx = 0; aiSnake.dy = 1;
                        } else if (dy < 0 && aiSnake.dy !== 1) {
                            aiSnake.dx = 0; aiSnake.dy = -1;
                        }
                    }
                }
            }
        }

        function findNearestItem(pos, items) {
            let nearest = null;
            let minDist = Infinity;

            for (let item of items) {
                const dist = Math.abs(pos.x - item.x) + Math.abs(pos.y - item.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = item;
                }
            }

            return nearest;
        }

        function aStarPathfinding(start, goal) {
            const openSet = [start];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const key = (pos) => `${pos.x},${pos.y}`;

            gScore.set(key(start), 0);
            fScore.set(key(start), heuristic(start, goal));

            let iterations = 0;
            const maxIterations = 100;

            while (openSet.length > 0 && iterations < maxIterations) {
                iterations++;

                // Find node with lowest fScore
                let current = openSet[0];
                let currentIdx = 0;
                for (let i = 1; i < openSet.length; i++) {
                    if (fScore.get(key(openSet[i])) < fScore.get(key(current))) {
                        current = openSet[i];
                        currentIdx = i;
                    }
                }

                if (current.x === goal.x && current.y === goal.y) {
                    return reconstructPath(cameFrom, current);
                }

                openSet.splice(currentIdx, 1);

                const neighbors = getNeighbors(current);
                for (let neighbor of neighbors) {
                    const tentativeGScore = gScore.get(key(current)) + 1;

                    if (!gScore.has(key(neighbor)) || tentativeGScore < gScore.get(key(neighbor))) {
                        cameFrom.set(key(neighbor), current);
                        gScore.set(key(neighbor), tentativeGScore);
                        fScore.set(key(neighbor), tentativeGScore + heuristic(neighbor, goal));

                        if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }

            return null;
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function getNeighbors(pos) {
            const neighbors = [];
            const dirs = [{x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}];

            for (let dir of dirs) {
                const neighbor = {x: pos.x + dir.x, y: pos.y + dir.y};

                // Wrap around
                if (neighbor.x < 0) neighbor.x = TILE_COUNT - 1;
                if (neighbor.x >= TILE_COUNT) neighbor.x = 0;
                if (neighbor.y < 0) neighbor.y = TILE_COUNT - 1;
                if (neighbor.y >= TILE_COUNT) neighbor.y = 0;

                // Check if walkable
                if (!isObstacle(neighbor)) {
                    neighbors.push(neighbor);
                }
            }

            return neighbors;
        }

        function reconstructPath(cameFrom, current) {
            const path = [current];
            const key = (pos) => `${pos.x},${pos.y}`;

            while (cameFrom.has(key(current))) {
                current = cameFrom.get(key(current));
                path.unshift(current);
            }

            return path;
        }

        function isObstacle(pos) {
            for (let obstacle of obstacles) {
                if (obstacle.x === pos.x && obstacle.y === pos.y) {
                    return true;
                }
            }
            return false;
        }

        function spawnObstacle() {
            // Random obstacle type
            const type = Math.random() < 0.7 ? 'static' : 'moving';

            let obstacle;
            let valid = false;
            let attempts = 0;

            while (!valid && attempts < 50) {
                attempts++;
                const x = Math.floor(Math.random() * TILE_COUNT);
                const y = Math.floor(Math.random() * TILE_COUNT);

                valid = true;

                // Check distance from snakes
                if (Math.abs(x - 10) < 5 && Math.abs(y - 10) < 5) valid = false;
                if (Math.abs(x - 20) < 5 && Math.abs(y - 20) < 5) valid = false;

                if (valid) {
                    obstacle = { x, y, type };

                    if (type === 'moving') {
                        obstacle.dx = Math.random() < 0.5 ? 1 : -1;
                        obstacle.dy = 0;
                        obstacle.moveCounter = 0;
                    }
                }
            }

            if (valid) {
                obstacles.push(obstacle);
            }
        }

        function updateObstacles() {
            for (let obstacle of obstacles) {
                if (obstacle.type === 'moving') {
                    obstacle.moveCounter++;

                    if (obstacle.moveCounter % 3 === 0) {
                        obstacle.x += obstacle.dx;
                        obstacle.y += obstacle.dy;

                        // Wrap around
                        if (obstacle.x < 0) obstacle.x = TILE_COUNT - 1;
                        if (obstacle.x >= TILE_COUNT) obstacle.x = 0;
                        if (obstacle.y < 0) obstacle.y = TILE_COUNT - 1;
                        if (obstacle.y >= TILE_COUNT) obstacle.y = 0;

                        // Random direction change
                        if (Math.random() < 0.1) {
                            const dirs = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
                            const dir = dirs[Math.floor(Math.random() * dirs.length)];
                            obstacle.dx = dir.dx;
                            obstacle.dy = dir.dy;
                        }
                    }
                }
            }
        }

        function updateShrinkZone() {
            if (!shrinkZone) {
                shrinkZone = { left: 0, top: 0, right: TILE_COUNT, bottom: TILE_COUNT };
            }

            // Shrink by 2 tiles from each side
            shrinkZone.left = Math.min(shrinkZone.left + 2, TILE_COUNT / 2 - 5);
            shrinkZone.top = Math.min(shrinkZone.top + 2, TILE_COUNT / 2 - 5);
            shrinkZone.right = Math.max(shrinkZone.right - 2, TILE_COUNT / 2 + 5);
            shrinkZone.bottom = Math.max(shrinkZone.bottom - 2, TILE_COUNT / 2 + 5);
        }

        function checkCollisions() {
            // Check obstacle collision for player
            if (!playerSnake.powerups.shield) {
                for (let obstacle of obstacles) {
                    if (obstacle.x === playerSnake.body[0].x && obstacle.y === playerSnake.body[0].y) {
                        createExplosion(playerSnake.body[0].x, playerSnake.body[0].y, playerSnake.color);
                        playCollisionSound();
                        endGame('You hit an obstacle!');
                        return true;
                    }
                }
            }

            return false;
        }

        function checkAppleCollisions() {
            // Player
            for (let i = apples.length - 1; i >= 0; i--) {
                const magnetRange = playerSnake.powerups.magnet ? 3 : 0;
                const dist = Math.abs(apples[i].x - playerSnake.body[0].x) +
                            Math.abs(apples[i].y - playerSnake.body[0].y);

                if (dist === 0 || (magnetRange > 0 && dist <= magnetRange)) {
                    const points = playerSnake.powerups.doublePoints ? 2 : 1;
                    playerScore += points;
                    totalApplesEaten++;
                    playerSnake.body.push({...playerSnake.body[playerSnake.body.length - 1]});
                    createScorePopup(apples[i].x, apples[i].y, `+${points}`);
                    createParticles(apples[i].x, apples[i].y, '#ffd93d');
                    apples.splice(i, 1);
                    spawnApple();
                    playEatSound();
                    updateDisplay();

                    // Check win condition for score race
                    if (gameMode === 'scoreRace' && playerScore >= 50) {
                        endGame('You reached 50 points first!');
                    }
                }
            }

            // AI
            for (let i = apples.length - 1; i >= 0; i--) {
                const magnetRange = aiSnake.powerups.magnet ? 3 : 0;
                const dist = Math.abs(apples[i].x - aiSnake.body[0].x) +
                            Math.abs(apples[i].y - aiSnake.body[0].y);

                if (dist === 0 || (magnetRange > 0 && dist <= magnetRange)) {
                    const points = aiSnake.powerups.doublePoints ? 2 : 1;
                    aiScore += points;
                    aiSnake.body.push({...aiSnake.body[aiSnake.body.length - 1]});
                    createParticles(apples[i].x, apples[i].y, '#ffd93d');
                    apples.splice(i, 1);
                    spawnApple();
                    updateDisplay();

                    // Check win condition for score race
                    if (gameMode === 'scoreRace' && aiScore >= 50) {
                        endGame('AI reached 50 points first!');
                    }
                }
            }
        }

        function checkPowerupCollisions() {
            // Player
            for (let i = powerups.length - 1; i >= 0; i--) {
                if (powerups[i].x === playerSnake.body[0].x &&
                    powerups[i].y === playerSnake.body[0].y) {
                    applyPowerup(playerSnake, powerups[i].type);
                    totalPowerupsCollected++;
                    createParticles(powerups[i].x, powerups[i].y, POWERUP_TYPES[powerups[i].type].color);
                    powerups.splice(i, 1);
                    playPowerupSound();
                }
            }

            // AI
            for (let i = powerups.length - 1; i >= 0; i--) {
                if (powerups[i].x === aiSnake.body[0].x &&
                    powerups[i].y === aiSnake.body[0].y) {
                    applyPowerup(aiSnake, powerups[i].type);
                    createParticles(powerups[i].x, powerups[i].y, POWERUP_TYPES[powerups[i].type].color);
                    powerups.splice(i, 1);
                }
            }
        }

        function applyPowerup(snake, type) {
            const powerup = POWERUP_TYPES[type];

            if (type === 'shrink' && snake.body.length > 3) {
                // Shrink snake by half
                const newLength = Math.max(3, Math.floor(snake.body.length / 2));
                snake.body = snake.body.slice(0, newLength);
            } else if (type === 'slow') {
                // Apply to opponent
                const opponent = snake === playerSnake ? aiSnake : playerSnake;
                opponent.powerups.slow = Date.now() + powerup.duration;
            } else {
                snake.powerups[type] = Date.now() + powerup.duration;
            }

            updatePowerupDisplay();
        }

        function updatePowerups() {
            const now = Date.now();

            // Remove expired powerups
            for (let key in playerSnake.powerups) {
                if (playerSnake.powerups[key] < now) {
                    delete playerSnake.powerups[key];
                }
            }

            for (let key in aiSnake.powerups) {
                if (aiSnake.powerups[key] < now) {
                    delete aiSnake.powerups[key];
                }
            }

            updatePowerupDisplay();
        }

        function updatePowerupDisplay() {
            const display = document.getElementById('powerupsDisplay');
            display.innerHTML = '';

            for (let key in playerSnake.powerups) {
                if (key === 'slow') continue;
                const timeLeft = Math.ceil((playerSnake.powerups[key] - Date.now()) / 1000);
                const div = document.createElement('div');
                div.className = 'active-powerup';
                div.innerHTML = `${POWERUP_TYPES[key].emoji} ${POWERUP_TYPES[key].name} (${timeLeft}s)`;
                display.appendChild(div);
            }
        }

        function spawnApple() {
            let apple;
            let valid = false;

            while (!valid) {
                apple = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };

                valid = true;

                // Check collisions
                for (let segment of playerSnake.body) {
                    if (segment.x === apple.x && segment.y === apple.y) {
                        valid = false;
                        break;
                    }
                }

                for (let segment of aiSnake.body) {
                    if (segment.x === apple.x && segment.y === apple.y) {
                        valid = false;
                        break;
                    }
                }

                for (let obstacle of obstacles) {
                    if (obstacle.x === apple.x && obstacle.y === apple.y) {
                        valid = false;
                        break;
                    }
                }
            }

            apples.push(apple);
        }

        function spawnPowerup() {
            if (powerups.length >= 3) return;

            let powerup;
            let valid = false;

            while (!valid) {
                const types = Object.keys(POWERUP_TYPES);
                const type = types[Math.floor(Math.random() * types.length)];

                powerup = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT),
                    type: type,
                    spawnTime: Date.now()
                };

                valid = true;

                // Check collisions
                for (let segment of playerSnake.body) {
                    if (segment.x === powerup.x && segment.y === powerup.y) {
                        valid = false;
                        break;
                    }
                }

                for (let segment of aiSnake.body) {
                    if (segment.x === powerup.x && segment.y === powerup.y) {
                        valid = false;
                        break;
                    }
                }

                for (let obstacle of obstacles) {
                    if (obstacle.x === powerup.x && obstacle.y === powerup.y) {
                        valid = false;
                        break;
                    }
                }
            }

            powerups.push(powerup);
        }

        function createParticles(gridX, gridY, color) {
            const x = gridX * GRID_SIZE + GRID_SIZE / 2;
            const y = gridY * GRID_SIZE + GRID_SIZE / 2;

            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    life: 1,
                    color: color
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                particles[i].life -= 0.02;

                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function createExplosion(gridX, gridY, color) {
            const x = gridX * GRID_SIZE + GRID_SIZE / 2;
            const y = gridY * GRID_SIZE + GRID_SIZE / 2;

            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color: color
                });
            }
        }

        function createScorePopup(gridX, gridY, text) {
            const x = gridX * GRID_SIZE + GRID_SIZE / 2;
            const y = gridY * GRID_SIZE + GRID_SIZE / 2;

            scorePopups.push({
                x: x,
                y: y,
                text: text,
                life: 1
            });
        }

        function updateScorePopups() {
            for (let i = scorePopups.length - 1; i >= 0; i--) {
                scorePopups[i].life -= 0.01;

                if (scorePopups[i].life <= 0) {
                    scorePopups.splice(i, 1);
                }
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw shrink zone warning
            if (shrinkZone) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#0f0f1e';
                ctx.fillRect(
                    shrinkZone.left * GRID_SIZE,
                    shrinkZone.top * GRID_SIZE,
                    (shrinkZone.right - shrinkZone.left) * GRID_SIZE,
                    (shrinkZone.bottom - shrinkZone.top) * GRID_SIZE
                );
            }

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= TILE_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }

            // Draw obstacles
            for (let obstacle of obstacles) {
                ctx.fillStyle = obstacle.type === 'moving' ? '#ff4444' : '#666';
                ctx.fillRect(
                    obstacle.x * GRID_SIZE + 1,
                    obstacle.y * GRID_SIZE + 1,
                    GRID_SIZE - 2,
                    GRID_SIZE - 2
                );

                // Draw movement indicator for moving obstacles
                if (obstacle.type === 'moving') {
                    ctx.fillStyle = '#fff';
                    const centerX = obstacle.x * GRID_SIZE + GRID_SIZE / 2;
                    const centerY = obstacle.y * GRID_SIZE + GRID_SIZE / 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw trails
            drawTrail(playerSnake);
            drawTrail(aiSnake);

            // Draw apples with glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffd93d';
            for (let apple of apples) {
                ctx.fillStyle = '#ffd93d';
                ctx.beginPath();
                ctx.arc(
                    apple.x * GRID_SIZE + GRID_SIZE / 2,
                    apple.y * GRID_SIZE + GRID_SIZE / 2,
                    GRID_SIZE / 2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(
                    apple.x * GRID_SIZE + GRID_SIZE / 3,
                    apple.y * GRID_SIZE + GRID_SIZE / 3,
                    GRID_SIZE / 6,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
            ctx.shadowBlur = 0;

            // Draw powerups with glow
            for (let powerup of powerups) {
                const type = POWERUP_TYPES[powerup.type];
                const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;

                ctx.shadowBlur = 15 * pulse;
                ctx.shadowColor = type.color;
                ctx.fillStyle = type.color;
                ctx.beginPath();
                ctx.arc(
                    powerup.x * GRID_SIZE + GRID_SIZE / 2,
                    powerup.y * GRID_SIZE + GRID_SIZE / 2,
                    GRID_SIZE / 2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Draw emoji
                ctx.shadowBlur = 0;
                ctx.font = `${GRID_SIZE - 4}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    type.emoji,
                    powerup.x * GRID_SIZE + GRID_SIZE / 2,
                    powerup.y * GRID_SIZE + GRID_SIZE / 2
                );
            }
            ctx.shadowBlur = 0;

            // Draw snakes
            drawSnake(playerSnake);
            drawSnake(aiSnake);

            // Draw particles
            for (let particle of particles) {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Draw score popups
            for (let popup of scorePopups) {
                ctx.globalAlpha = popup.life;
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#ffd700';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(popup.text, popup.x, popup.y - (1 - popup.life) * 30);
                ctx.fillText(popup.text, popup.x, popup.y - (1 - popup.life) * 30);
            }
            ctx.globalAlpha = 1;
        }

        function drawTrail(snake) {
            for (let i = 0; i < snake.trail.length; i++) {
                const trail = snake.trail[i];
                ctx.globalAlpha = trail.life * 0.3 * (i / snake.trail.length);
                ctx.fillStyle = snake.color;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawSnake(snake) {
            for (let i = 0; i < snake.body.length; i++) {
                const segment = snake.body[i];
                const isHead = i === 0;

                // Shield effect
                if (isHead && snake.powerups.shield) {
                    const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
                    ctx.strokeStyle = 'rgba(135, 206, 235, ' + pulse + ')';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        segment.x * GRID_SIZE,
                        segment.y * GRID_SIZE,
                        GRID_SIZE,
                        GRID_SIZE
                    );
                }

                // Body with gradient
                const gradient = ctx.createLinearGradient(
                    segment.x * GRID_SIZE,
                    segment.y * GRID_SIZE,
                    segment.x * GRID_SIZE + GRID_SIZE,
                    segment.y * GRID_SIZE + GRID_SIZE
                );

                const alpha = 1 - (i / snake.body.length) * 0.3;
                if (snake.color === '#4ade80') {
                    gradient.addColorStop(0, `rgba(74, 222, 128, ${alpha})`);
                    gradient.addColorStop(1, `rgba(34, 197, 94, ${alpha})`);
                } else {
                    gradient.addColorStop(0, `rgba(255, 107, 107, ${alpha})`);
                    gradient.addColorStop(1, `rgba(239, 68, 68, ${alpha})`);
                }

                ctx.fillStyle = gradient;
                ctx.fillRect(
                    segment.x * GRID_SIZE + 1,
                    segment.y * GRID_SIZE + 1,
                    GRID_SIZE - 2,
                    GRID_SIZE - 2
                );

                // Head highlight
                if (isHead) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(
                        segment.x * GRID_SIZE + 4,
                        segment.y * GRID_SIZE + 4,
                        GRID_SIZE - 8,
                        GRID_SIZE - 8
                    );

                    // Eyes
                    ctx.fillStyle = '#000';
                    const eyeSize = 2;
                    ctx.fillRect(
                        segment.x * GRID_SIZE + 6,
                        segment.y * GRID_SIZE + 6,
                        eyeSize,
                        eyeSize
                    );
                    ctx.fillRect(
                        segment.x * GRID_SIZE + GRID_SIZE - 6 - eyeSize,
                        segment.y * GRID_SIZE + 6,
                        eyeSize,
                        eyeSize
                    );
                }
            }
        }

        function drawMinimap() {
            const scale = minimap.width / canvas.width;
            minimapCtx.fillStyle = '#0f0f1e';
            minimapCtx.fillRect(0, 0, minimap.width, minimap.height);

            // Draw apples
            minimapCtx.fillStyle = '#ffd93d';
            for (let apple of apples) {
                minimapCtx.fillRect(
                    apple.x * GRID_SIZE * scale,
                    apple.y * GRID_SIZE * scale,
                    Math.max(2, GRID_SIZE * scale),
                    Math.max(2, GRID_SIZE * scale)
                );
            }

            // Draw powerups
            minimapCtx.fillStyle = '#ff69b4';
            for (let powerup of powerups) {
                minimapCtx.fillRect(
                    powerup.x * GRID_SIZE * scale,
                    powerup.y * GRID_SIZE * scale,
                    Math.max(2, GRID_SIZE * scale),
                    Math.max(2, GRID_SIZE * scale)
                );
            }

            // Draw obstacles
            minimapCtx.fillStyle = '#666';
            for (let obstacle of obstacles) {
                minimapCtx.fillRect(
                    obstacle.x * GRID_SIZE * scale,
                    obstacle.y * GRID_SIZE * scale,
                    Math.max(2, GRID_SIZE * scale),
                    Math.max(2, GRID_SIZE * scale)
                );
            }

            // Draw player snake
            minimapCtx.fillStyle = '#4ade80';
            for (let segment of playerSnake.body) {
                minimapCtx.fillRect(
                    segment.x * GRID_SIZE * scale,
                    segment.y * GRID_SIZE * scale,
                    Math.max(2, GRID_SIZE * scale),
                    Math.max(2, GRID_SIZE * scale)
                );
            }

            // Draw AI snake
            minimapCtx.fillStyle = '#ff6b6b';
            for (let segment of aiSnake.body) {
                minimapCtx.fillRect(
                    segment.x * GRID_SIZE * scale,
                    segment.y * GRID_SIZE * scale,
                    Math.max(2, GRID_SIZE * scale),
                    Math.max(2, GRID_SIZE * scale)
                );
            }
        }

        function updateTimer() {
            timeRemaining--;
            updateDisplay();

            if (timeRemaining <= 0) {
                endGame();
            }
        }

        function updateDisplay() {
            const timeDisplay = document.getElementById('timeDisplay');

            if (gameMode === 'timeAttack') {
                timeDisplay.textContent = timeRemaining;
                timeDisplay.className = 'stat-value';

                if (timeRemaining <= 10) {
                    timeDisplay.className = 'stat-value time-critical';
                } else if (timeRemaining <= 20) {
                    timeDisplay.className = 'stat-value time-warning';
                }
            } else {
                timeDisplay.textContent = timeRemaining;
            }

            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('aiScore').textContent = aiScore;
        }

        function updateModeDisplay() {
            const modeNames = {
                timeAttack: 'Time Attack',
                survival: 'Survival',
                scoreRace: 'Score Race',
                endless: 'Endless'
            };
            const diffNames = {
                easy: 'üòä Easy',
                normal: 'üòê Normal',
                hard: 'üò∞ Hard',
                insane: 'üíÄ Insane'
            };
            document.getElementById('modeDisplay').innerHTML =
                `${modeNames[gameMode]}<br><span style="font-size: 0.8em;">${diffNames[difficulty]}</span>`;
        }

        function endGame(message = null) {
            gameActive = false;
            clearInterval(gameLoop);
            clearInterval(timerInterval);

            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('resultTitle');
            const resultMsg = document.getElementById('resultMessage');
            const statsGrid = document.getElementById('statsGrid');

            let titleText = '';
            let messageText = '';

            if (message) {
                titleText = 'üíÄ Game Over';
                messageText = message;
                playDefeatSound();
            } else if (gameMode === 'scoreRace') {
                if (playerScore >= 50) {
                    titleText = 'üéâ You Win! üéâ';
                    messageText = 'You reached 50 points first!';
                    playVictorySound();
                } else {
                    titleText = 'ü§ñ AI Wins!';
                    messageText = 'AI reached 50 points first!';
                    playDefeatSound();
                }
            } else {
                if (playerScore > aiScore) {
                    titleText = 'üéâ You Win! üéâ';
                    messageText = `Your Score: ${playerScore} | AI Score: ${aiScore}`;
                    playVictorySound();
                } else if (aiScore > playerScore) {
                    titleText = 'ü§ñ AI Wins!';
                    messageText = `AI Score: ${aiScore} | Your Score: ${playerScore}`;
                    playDefeatSound();
                } else {
                    titleText = 'ü§ù It\'s a Tie!';
                    messageText = `Both scored ${playerScore} points!`;
                    playDefeatSound();
                }
            }

            title.textContent = titleText;
            resultMsg.textContent = messageText;

            // Update highscore
            if (playerScore > highScore) {
                highScore = playerScore;
                localStorage.setItem('snakeBattleHighScore', highScore);
            }

            // Display stats
            const gameDuration = Math.floor((Date.now() - gameStartTime) / 1000);
            statsGrid.innerHTML = `
                <div>üèÜ High Score:</div><div><strong>${highScore}</strong></div>
                <div>‚è±Ô∏è Time Played:</div><div><strong>${gameDuration}s</strong></div>
                <div>üçé Apples Eaten:</div><div><strong>${totalApplesEaten}</strong></div>
                <div>‚ö° Powerups Collected:</div><div><strong>${totalPowerupsCollected}</strong></div>
                <div>üìè Final Length:</div><div><strong>${playerSnake.body.length}</strong></div>
                <div>üéØ Difficulty:</div><div><strong>${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}</strong></div>
            `;

            modal.classList.add('active');
        }

        function goHome() {
            window.location.href = 'index.html';
        }

        // Mobile touch controls - Swipe gestures
        let touchStartXPos = 0;
        let touchStartYPos = 0;
        let touchEndXPos = 0;
        let touchEndYPos = 0;
        const minSwipeDistance = 30;

        canvas.addEventListener('touchstart', (e) => {
            touchStartXPos = e.touches[0].clientX;
            touchStartYPos = e.touches[0].clientY;
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            touchEndXPos = e.touches[0].clientX;
            touchEndYPos = e.touches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (!gameActive || gamePaused) return;

            const deltaX = touchEndXPos - touchStartXPos;
            const deltaY = touchEndYPos - touchStartYPos;

            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                // Horizontal swipe
                if (deltaX > 0 && playerSnake.dx !== -1) {
                    // Swipe right
                    playerSnake.nextDx = 1;
                    playerSnake.nextDy = 0;
                } else if (deltaX < 0 && playerSnake.dx !== 1) {
                    // Swipe left
                    playerSnake.nextDx = -1;
                    playerSnake.nextDy = 0;
                }
            } else if (Math.abs(deltaY) > minSwipeDistance) {
                // Vertical swipe
                if (deltaY > 0 && playerSnake.dy !== -1) {
                    // Swipe down
                    playerSnake.nextDx = 0;
                    playerSnake.nextDy = 1;
                } else if (deltaY < 0 && playerSnake.dy !== 1) {
                    // Swipe up
                    playerSnake.nextDx = 0;
                    playerSnake.nextDy = -1;
                }
            }
        }, { passive: true });

        // D-Pad button controls
        document.getElementById('dpadUp')?.addEventListener('click', () => {
            if (!gameActive || gamePaused) return;
            if (playerSnake.dy !== 1) {
                playerSnake.nextDx = 0;
                playerSnake.nextDy = -1;
            }
        });

        document.getElementById('dpadDown')?.addEventListener('click', () => {
            if (!gameActive || gamePaused) return;
            if (playerSnake.dy !== -1) {
                playerSnake.nextDx = 0;
                playerSnake.nextDy = 1;
            }
        });

        document.getElementById('dpadLeft')?.addEventListener('click', () => {
            if (!gameActive || gamePaused) return;
            if (playerSnake.dx !== 1) {
                playerSnake.nextDx = -1;
                playerSnake.nextDy = 0;
            }
        });

        document.getElementById('dpadRight')?.addEventListener('click', () => {
            if (!gameActive || gamePaused) return;
            if (playerSnake.dx !== -1) {
                playerSnake.nextDx = 1;
                playerSnake.nextDy = 0;
            }
        });

        // Touch events for D-pad buttons (faster response)
        ['dpadUp', 'dpadDown', 'dpadLeft', 'dpadRight'].forEach(id => {
            document.getElementById(id)?.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const event = new Event('click');
                e.target.dispatchEvent(event);
            });
        });

        // Initial draw
        draw();
        drawMinimap();
    </script>
</body>
</html>
