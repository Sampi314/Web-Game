<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Just a Card Flip Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Mobile optimizations */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overscroll-behavior: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .container {
            text-align: center;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .icon-selector {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .dimension-selector {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .sound-settings {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .sound-settings h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .volume-control {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }

        .volume-control label {
            color: white;
            font-weight: bold;
            min-width: 100px;
        }

        .volume-control input[type="range"] {
            width: 200px;
            cursor: pointer;
        }

        .volume-control span {
            color: white;
            font-weight: bold;
            min-width: 40px;
        }

        .dimension-selector h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .dimension-inputs {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .dimension-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .dimension-input label {
            color: white;
            font-weight: bold;
        }

        .dimension-input input {
            width: 60px;
            padding: 8px;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 1em;
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
        }

        .apply-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 10px 25px;
            font-size: 1em;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .apply-btn:hover {
            transform: translateY(-2px);
        }

        .error-message {
            color: #ff6b6b;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 0.9em;
            margin-top: 10px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .icon-selector h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .icon-sets {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }

        .icon-set-btn {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: 2px solid white;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.3s;
        }

        .icon-set-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .icon-set-btn.active {
            background: white;
            color: #667eea;
        }
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .custom-icons input {
            padding: 8px 15px;
            border: 2px solid white;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 1em;
            width: 300px;
        }

        .custom-icons button {
            padding: 8px 20px;
            font-size: 0.9em;
        }

        .icon-hint {
            color: white;
            font-size: 0.85em;
            margin-top: 8px;
            opacity: 0.9;
        }

        .settings-toggle {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: 2px solid white;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .settings-toggle:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .music-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: 2px solid white;
            padding: 12px 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
        }

        .music-toggle:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }

        .music-toggle.playing {
            background: rgba(255, 215, 0, 0.4);
        }

        .settings-panel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .settings-panel.open {
            max-height: 800px;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .mode-selector label {
            color: white;
            font-weight: bold;
            font-size: 1.2em;
        }

        .mode-dropdown {
            padding: 10px 20px;
            border: 2px solid white;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
        }

        .info-panel {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.2);
            padding: 12px 25px;
            border-radius: 10px;
            color: white;
            font-size: 1em;
            backdrop-filter: blur(10px);
        }

        .info-box span {
            font-weight: bold;
            font-size: 1.4em;
        }

        .info-box.score {
            background: rgba(255, 215, 0, 0.3);
        }

        .info-box.combo {
            background: rgba(255, 100, 100, 0.3);
            animation: pulse 0.5s ease-in-out;
        }

        .info-box.combo.active {
            animation: pulse 0.5s ease-in-out infinite;
        }

        .combo-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            pointer-events: none;
            opacity: 0;
            z-index: 1000;
            animation: comboPopup 1s ease-out;
        }

        @keyframes comboPopup {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -60%) scale(1);
            }
        }

        .game-board {
            display: grid;
            gap: 15px;
            max-width: min(90vw, 600px);
            margin: 0 auto 30px;
            perspective: 1000px;
            transition: transform 0.8s ease-in-out;
            position: relative;
        }

        .card {
            aspect-ratio: 1 / 1;
            width: 100%;
            background: white;
            border-radius: 15px;
            cursor: pointer;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            /* Prevent context menu on long press */
            -webkit-touch-callout: none;
        }

        .card.animating {
            transition: all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 10;
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card.matched {
            cursor: default;
        }

        /* Theme-specific matched card glow effects */
        body.theme-ocean .card.matched {
            box-shadow: 0 0 20px rgba(27, 255, 255, 0.6);
        }

        body.theme-sunset .card.matched {
            box-shadow: 0 0 20px rgba(255, 217, 61, 0.6);
        }

        body.theme-forest .card.matched {
            box-shadow: 0 0 20px rgba(113, 178, 128, 0.6);
        }

        body.theme-midnight .card.matched {
            box-shadow: 0 0 20px rgba(100, 181, 246, 0.6);
        }

        body.theme-candy .card.matched {
            box-shadow: 0 0 20px rgba(252, 70, 107, 0.6);
        }

        body.theme-purple .card.matched {
            box-shadow: 0 0 20px rgba(118, 75, 162, 0.6);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 15px;
            font-size: 3em;
            transition: transform 0.8s ease-in-out;
        }

        .card-front {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: rotateY(180deg);
        }

        .card-back {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .card-back::after {
            content: "?";
            font-size: 3em;
            color: white;
            font-weight: bold;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        button {
            background: white;
            color: #667eea;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            /* Ensure minimum touch target size */
            min-width: 44px;
            min-height: 44px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .win-message {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .win-message.show {
            display: block;
        }

        .win-message h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 2.5em;
        }

        .win-message p {
            color: #555;
            font-size: 1.3em;
        }

        @media (max-width: 600px) {
            .game-board {
                gap: 10px;
            }
            
            .card-face {
                font-size: 2em;
            }
            
            h1 {
                font-size: 2em;
            }
        }


        /* Name input modal */
        .name-input-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1001;
            transition: transform 0.3s;
            text-align: center;
            min-width: 400px;
            max-width: 90vw;
        }

        .name-input-modal.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .name-input-modal h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .name-input-modal input {
            width: 100%;
            padding: 12px 20px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .name-input-modal input:focus {
            outline: none;
            border-color: #764ba2;
        }

        .name-input-modal button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .name-input-modal button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
        }

        .modal-overlay.show {
            display: block;
        }

        /* Game Statistics Styles */
        .stats-toggle {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: 2px solid white;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .stats-toggle:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .stats-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin: 20px auto;
            max-width: 700px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none;
        }

        .stats-container.show {
            display: block;
        }

        .stats-container h2 {
            color: #667eea;
            margin-bottom: 25px;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-card-subtext {
            font-size: 0.85em;
            opacity: 0.8;
        }

        .stats-section {
            background: rgba(102, 126, 234, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .stats-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(102, 126, 234, 0.2);
        }

        .stats-row:last-child {
            border-bottom: none;
        }

        .stats-label {
            color: #666;
            font-weight: 500;
        }

        .stats-value {
            color: #667eea;
            font-weight: bold;
        }

        .reset-stats-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            display: block;
            margin: 20px auto 0;
        }

        .reset-stats-btn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }

        /* Theme Selector Styles */
        .theme-selector {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .theme-selector h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .theme-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .theme-btn {
            padding: 12px 25px;
            border: 2px solid white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.3s;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .theme-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .theme-btn.active {
            border-width: 3px;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        .theme-btn.purple {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .theme-btn.ocean {
            background: linear-gradient(135deg, #2E3192 0%, #1BFFFF 100%);
        }

        .theme-btn.sunset {
            background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
        }

        .theme-btn.forest {
            background: linear-gradient(135deg, #134E5E 0%, #71B280 100%);
        }

        .theme-btn.midnight {
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
        }

        .theme-btn.candy {
            background: linear-gradient(135deg, #FC466B 0%, #3F5EFB 100%);
        }

        /* Theme-specific body backgrounds */
        body.theme-purple {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        body.theme-ocean {
            background: linear-gradient(135deg, #2E3192 0%, #1BFFFF 100%);
        }

        body.theme-sunset {
            background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
        }

        body.theme-forest {
            background: linear-gradient(135deg, #134E5E 0%, #71B280 100%);
        }

        body.theme-midnight {
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
        }

        body.theme-candy {
            background: linear-gradient(135deg, #FC466B 0%, #3F5EFB 100%);
        }

        /* Theme-specific stat cards */
        body.theme-ocean .stat-card {
            background: linear-gradient(135deg, #2E3192 0%, #1BFFFF 100%);
        }

        body.theme-sunset .stat-card {
            background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
        }

        body.theme-forest .stat-card {
            background: linear-gradient(135deg, #134E5E 0%, #71B280 100%);
        }

        body.theme-midnight .stat-card {
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
        }

        body.theme-candy .stat-card {
            background: linear-gradient(135deg, #FC466B 0%, #3F5EFB 100%);
        }

        /* Theme-specific accent colors */
        body.theme-ocean .stats-value {
            background: linear-gradient(135deg, #2E3192 0%, #1BFFFF 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        body.theme-sunset .stats-value {
            background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        body.theme-forest .stats-value {
            background: linear-gradient(135deg, #134E5E 0%, #71B280 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        body.theme-midnight .stats-value {
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        body.theme-candy .stats-value {
            background: linear-gradient(135deg, #FC466B 0%, #3F5EFB 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Theme-specific card backs */
        body.theme-purple .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
        }

        body.theme-ocean .card-back {
            background: linear-gradient(135deg, #2E3192 0%, #1BFFFF 100%);
            border: 3px solid rgba(255, 255, 255, 0.9);
        }

        body.theme-sunset .card-back {
            background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
            border: 3px solid rgba(255, 255, 255, 0.9);
        }

        body.theme-forest .card-back {
            background: linear-gradient(135deg, #134E5E 0%, #71B280 100%);
            border: 3px solid rgba(255, 255, 255, 0.9);
        }

        body.theme-midnight .card-back {
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
            border: 3px solid rgba(100, 200, 255, 0.8);
        }

        body.theme-candy .card-back {
            background: linear-gradient(135deg, #FC466B 0%, #3F5EFB 100%);
            border: 3px solid rgba(255, 255, 255, 0.9);
        }

        /* Theme-specific card fronts */
        body.theme-ocean .card-front {
            background: linear-gradient(135deg, #e0f7ff 0%, #ffffff 100%);
            border: 3px solid #1BFFFF;
        }

        body.theme-sunset .card-front {
            background: linear-gradient(135deg, #fff5e6 0%, #ffffff 100%);
            border: 3px solid #FFD93D;
        }

        body.theme-forest .card-front {
            background: linear-gradient(135deg, #e8f5e9 0%, #ffffff 100%);
            border: 3px solid #71B280;
        }

        body.theme-midnight .card-front {
            background: linear-gradient(135deg, #1a2332 0%, #2d3e50 100%);
            border: 3px solid #64b5f6;
            color: #ffffff;
        }

        body.theme-candy .card-front {
            background: linear-gradient(135deg, #ffe6f0 0%, #ffffff 100%);
            border: 3px solid #FC466B;
        }


        /* Peek Mode Styles */
        .peek-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 2em;
            font-weight: bold;
            z-index: 2000;
            text-align: center;
            display: none;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        .peek-overlay.show {
            display: block;
            animation: peekPulse 1s infinite;
        }

        @keyframes peekPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }

        .peek-message {
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .peek-timer {
            font-size: 1.5em;
            color: #ffd700;
        }

        /* Memory Fade Mode Styles */
        .card.fading {
            opacity: 0.3;
            filter: blur(2px);
            transition: opacity 3s ease, filter 3s ease;
        }

        .card.fading .card-front,
        .card.fading .card-back {
            opacity: 0.3;
            filter: blur(2px);
        }

        /* Fortune Teller Mode Styles */
        .card.hint-glow {
            animation: hintGlow 1.5s ease-in-out;
        }

        @keyframes hintGlow {
            0%, 100% {
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 50px rgba(255, 215, 0, 0.5);
                transform: scale(1.05);
            }
        }

        .fortune-message {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 1.1em;
            font-weight: bold;
            z-index: 1500;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .fortune-message.show {
            opacity: 1;
        }

        /* Color Chaos Mode Styles */
        .card.color-shift {
            transition: background 2s ease;
        }

        .card.color-shift .card-back {
            transition: background 2s ease, border-color 2s ease;
        }
    </style>
</head>
<body class="theme-purple">
    <button class="music-toggle" id="musicToggle" onclick="toggleMusic()">ğŸ”‡</button>
    
    <div class="container">
        <h1>ğŸ´ Just a Card Flip Game</h1>
        
        <button class="settings-toggle" onclick="toggleSettings()">âš™ï¸ Settings</button>
        <button class="stats-toggle" onclick="toggleStats()">ğŸ“Š Statistics</button>
        <a href="leaderboard.html" style="display: inline-block; margin-bottom: 15px;">
            <button class="settings-toggle" style="margin-bottom: 0;">ğŸ† Global Leaderboard</button>
        </a>
        
        <div class="settings-panel" id="settingsPanel">
            <div class="dimension-selector">
                <h3>Board Size:</h3>
                <div class="dimension-inputs">
                    <div class="dimension-input">
                        <label>Width:</label>
                        <input type="number" id="boardWidth" value="4" min="2">
                    </div>
                    <div class="dimension-input">
                        <label>Height:</label>
                        <input type="number" id="boardHeight" value="4" min="2">
                    </div>
                    <button class="apply-btn" onclick="applyDimensions()">Apply</button>
                </div>
                <div class="error-message" id="errorMessage"></div>
            </div>
            
            <div class="icon-selector">
                <h3>Choose Icon Set:</h3>
                <div class="icon-sets">
                    <button class="icon-set-btn active" onclick="setIconSet('gaming')">ğŸ® Gaming</button>
                    <button class="icon-set-btn" onclick="setIconSet('animals')">ğŸ¶ Animals</button>
                    <button class="icon-set-btn" onclick="setIconSet('food')">ğŸ• Food</button>
                    <button class="icon-set-btn" onclick="setIconSet('sports')">âš½ Sports</button>
                    <button class="icon-set-btn" onclick="setIconSet('nature')">ğŸŒ¸ Nature</button>
                    <button class="icon-set-btn" onclick="setIconSet('numbers')">1ï¸âƒ£ Numbers</button>
                    <button class="icon-set-btn" onclick="setIconSet('horoscope')">â™ˆ Horoscope</button>
                    <button class="icon-set-btn" onclick="setIconSet('custom')">âœï¸ Custom</button>
                </div>
                <div class="custom-icons" id="customInput" style="display: none;">
                    <input type="text" id="customEmojis" placeholder="Enter 8 emojis separated by spaces (e.g., ğŸ¨ ğŸ­ ğŸª ğŸ¯ ğŸ¸ ğŸº ğŸ¹ ğŸ²)">
                    <button onclick="applyCustomIcons()">Apply</button>
                </div>
                <div class="icon-hint">Icons will repeat if board size exceeds available unique icons</div>
            </div>

            <div class="sound-settings">
                <h3>Sound Settings:</h3>
                <div class="volume-control">
                    <label>Music Volume:</label>
                    <input type="range" id="musicVolume" min="0" max="100" value="50" oninput="updateMusicVolume(this.value)">
                    <span id="musicVolumeDisplay">50%</span>
                </div>
                <div class="volume-control">
                    <label>SFX Volume:</label>
                    <input type="range" id="sfxVolume" min="0" max="100" value="70" oninput="updateSFXVolume(this.value)">
                    <span id="sfxVolumeDisplay">70%</span>
                </div>
            </div>

            <div class="theme-selector">
                <h3>ğŸ¨ Choose Theme:</h3>
                <div class="theme-options">
                    <button class="theme-btn purple active" onclick="setTheme('purple')">Purple Dream</button>
                    <button class="theme-btn ocean" onclick="setTheme('ocean')">Ocean Blue</button>
                    <button class="theme-btn sunset" onclick="setTheme('sunset')">Sunset Orange</button>
                    <button class="theme-btn forest" onclick="setTheme('forest')">Forest Green</button>
                    <button class="theme-btn midnight" onclick="setTheme('midnight')">Midnight</button>
                    <button class="theme-btn candy" onclick="setTheme('candy')">Candy Pop</button>
                </div>
            </div>
        </div>
        
        <div class="mode-selector">
            <label>Game Mode:</label>
            <select class="mode-dropdown" id="modeSelect" onchange="setMode(this.value)">
                <option value="normal">ğŸ® Normal Mode</option>
                <option value="peek">ğŸ‘ï¸ Peek Mode</option>
                <option value="fade">ğŸŒ«ï¸ Memory Fade</option>
                <option value="fortune">ğŸ”® Fortune Teller</option>
                <option value="color">ğŸŒˆ Color Chaos</option>
                <option value="chaos">ğŸŒ€ Chaos Mode</option>
                <option value="swap">ğŸ”„ Swap Mode</option>
                <option value="rotate">ğŸ”ƒ Rotate Mode</option>
            </select>
        </div>
        
        <div class="info-panel">
            <div class="info-box score">
                Score: <span id="score">0</span>
            </div>
            <div class="info-box combo" id="comboBox">
                Combo: <span id="combo">0</span>x
            </div>
            <div class="info-box">
                Moves: <span id="moves">0</span>
            </div>
            <div class="info-box">
                Time: <span id="timer">0</span>s
            </div>
        </div>

        <!-- Name Input Modal -->
        <div class="modal-overlay" id="modalOverlay"></div>
        <div class="name-input-modal" id="nameInputModal">
            <h3>ğŸ‰ Congratulations!</h3>
            <p style="color: #666; margin-bottom: 20px;">Enter your name for the leaderboard:</p>
            <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20" />
            <button onclick="submitScore()">Submit Score</button>
        </div>

        <!-- Statistics Panel -->
        <div id="statsPanel" class="stats-container">
            <h2>ğŸ“Š Game Statistics</h2>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-card-label">Games Played</div>
                    <div class="stat-card-value" id="statGamesPlayed">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Average Score</div>
                    <div class="stat-card-value" id="statAvgScore">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Best Score</div>
                    <div class="stat-card-value" id="statBestScore">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Total Playtime</div>
                    <div class="stat-card-value" id="statTotalTime">0m</div>
                </div>
            </div>

            <div class="stats-section">
                <h3>âš¡ Performance Stats</h3>
                <div class="stats-row">
                    <span class="stats-label">Average Time per Game</span>
                    <span class="stats-value" id="statAvgTime">0s</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">Average Moves per Game</span>
                    <span class="stats-value" id="statAvgMoves">0</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">Best Time</span>
                    <span class="stats-value" id="statBestTime">--</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">Fewest Moves</span>
                    <span class="stats-value" id="statBestMoves">--</span>
                </div>
            </div>

            <div class="stats-section">
                <h3>ğŸ¯ Accuracy</h3>
                <div class="stats-row">
                    <span class="stats-label">Total Matches</span>
                    <span class="stats-value" id="statTotalMatches">0</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">Total Attempts</span>
                    <span class="stats-value" id="statTotalAttempts">0</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">Match Accuracy</span>
                    <span class="stats-value" id="statAccuracy">0%</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">Best Combo Streak</span>
                    <span class="stats-value" id="statBestCombo">0</span>
                </div>
            </div>

            <div class="stats-section">
                <h3>ğŸ® Current Session</h3>
                <div class="stats-row">
                    <span class="stats-label">Games This Session</span>
                    <span class="stats-value" id="statSessionGames">0</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">Win Streak</span>
                    <span class="stats-value" id="statWinStreak">0</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">Best Win Streak</span>
                    <span class="stats-value" id="statBestStreak">0</span>
                </div>
            </div>

            <button class="reset-stats-btn" onclick="resetStatistics()">Reset All Statistics</button>
        </div>

        <!-- Peek Mode Overlay -->
        <div id="peekOverlay" class="peek-overlay">
            <div class="peek-message">ğŸ‘ï¸ Memorize the cards!</div>
            <div class="peek-timer" id="peekTimer">5</div>
        </div>

        <!-- Fortune Teller Message -->
        <div id="fortuneMessage" class="fortune-message"></div>

        <div class="win-message" id="winMessage">
            <h2>ğŸ‰ You Won!</h2>
            <p>Score: <span id="finalScore"></span></p>
            <p>Moves: <span id="finalMoves"></span> | Time: <span id="finalTime"></span>s</p>
        </div>

        <div class="game-board" id="gameBoard"></div>

        <button onclick="resetGame()">Play Again</button>
    </div>

    <script>
        const iconSets = {
            gaming: ['ğŸ®', 'ğŸ¨', 'ğŸ­', 'ğŸª', 'ğŸ¯', 'ğŸ¸', 'ğŸº', 'ğŸ¹', 'ğŸ²', 'ğŸ°', 'ğŸ³', 'ğŸ†', 'ğŸ–ï¸', 'ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', 'ğŸ¬', 'ğŸ¤', 'ğŸ§', 'ğŸ¼', 'ğŸµ', 'ğŸ¶', 'ğŸ»', 'ğŸ·', 'ğŸ¥', 'ğŸ¹', 'ğŸº', 'ğŸª•', 'ğŸ¸', 'ğŸª—', 'ğŸšï¸', 'ğŸ›ï¸'],
            animals: ['ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ¸', 'ğŸµ', 'ğŸ”', 'ğŸ§', 'ğŸ¦', 'ğŸ¤', 'ğŸ¦†', 'ğŸ¦…', 'ğŸ¦‰', 'ğŸ¦‡', 'ğŸº', 'ğŸ—', 'ğŸ´', 'ğŸ¦„', 'ğŸ', 'ğŸ›', 'ğŸ¦‹', 'ğŸŒ', 'ğŸ'],
            food: ['ğŸ•', 'ğŸ”', 'ğŸŸ', 'ğŸŒ­', 'ğŸ¿', 'ğŸ§', 'ğŸ©', 'ğŸª', 'ğŸ°', 'ğŸ‚', 'ğŸ¦', 'ğŸ¨', 'ğŸ§', 'ğŸ¥¤', 'ğŸ¹', 'ğŸ«', 'ğŸ¬', 'ğŸ­', 'ğŸ®', 'ğŸ¯', 'ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ«', 'ğŸˆ', 'ğŸ’', 'ğŸ‘', 'ğŸ¥­'],
            sports: ['âš½', 'ğŸ€', 'ğŸˆ', 'âš¾', 'ğŸ¾', 'ğŸ', 'ğŸ‰', 'ğŸ±', 'ğŸ“', 'ğŸ¸', 'ğŸ¥Š', 'ğŸ¥‹', 'â›³', 'ğŸ¯', 'ğŸ¹', 'ğŸ¥', 'ğŸªƒ', 'ğŸ›¹', 'ğŸ›¼', 'ğŸ¿', 'â›·ï¸', 'ğŸ‚', 'ğŸª‚', 'ğŸ‹ï¸', 'ğŸ¤¸', 'ğŸ¤º', 'â›¹ï¸', 'ğŸ¤¾', 'ğŸ‡', 'ğŸ§—', 'ğŸš´', 'ğŸŠ'],
            nature: ['ğŸŒ¸', 'ğŸŒº', 'ğŸŒ»', 'ğŸŒ·', 'ğŸŒ¹', 'ğŸŒ¼', 'ğŸŒ´', 'ğŸŒµ', 'ğŸ€', 'ğŸŒ¿', 'ğŸ', 'ğŸ‚', 'ğŸŒ¾', 'ğŸŒ²', 'ğŸŒ³', 'ğŸµï¸', 'ğŸŒ±', 'ğŸª´', 'ğŸŒ¾', 'ğŸ’', 'ğŸ¥€', 'ğŸ”ï¸', 'â›°ï¸', 'ğŸŒ‹', 'ğŸ—»', 'ğŸ•ï¸', 'ğŸ–ï¸', 'ğŸœï¸', 'ğŸï¸', 'ğŸŒŠ', 'ğŸŒ¬ï¸', 'ğŸŒˆ'],
            numbers: ['0ï¸âƒ£', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ğŸ”Ÿ', 'ğŸ”¢', '#ï¸âƒ£', '*ï¸âƒ£', 'â•', 'â–', 'âœ–ï¸', 'â—', 'ğŸŸ°', 'ğŸ’¯', 'ğŸ”´', 'ğŸŸ ', 'ğŸŸ¡', 'ğŸŸ¢', 'ğŸ”µ', 'ğŸŸ£', 'ğŸŸ¤', 'âš«', 'âšª', 'ğŸŸ¥', 'ğŸŸ§', 'ğŸŸ¨'],
            horoscope: ['â™ˆ', 'â™‰', 'â™Š', 'â™‹', 'â™Œ', 'â™', 'â™', 'â™', 'â™', 'â™‘', 'â™’', 'â™“', 'â­', 'ğŸŒŸ', 'âœ¨', 'ğŸ’«', 'ğŸŒ™', 'â˜€ï¸', 'ğŸŒ', 'ğŸŒ', 'ğŸŒ›', 'ğŸŒœ', 'ğŸŒš', 'ğŸŒ•', 'ğŸŒ–', 'ğŸŒ—', 'ğŸŒ˜', 'ğŸŒ‘', 'ğŸŒ’', 'ğŸŒ“', 'ğŸŒ”', 'âš¡']
        };
        
        let currentIconSet = 'gaming';
        let boardWidth = 4;
        let boardHeight = 4;
        let emojis = [...iconSets.gaming].slice(0, 8);
        let cards = [...emojis, ...emojis];
        let flippedCards = [];
        let matchedPairs = 0;
        let moves = 0;
        let timer = 0;
        let timerInterval;
        let canFlip = true;
        let gameMode = 'normal';
        let cardRevealTimes = new Map(); // Track when cards were revealed for fade mode
        let colorShiftInterval = null; // Track color shift for Color Chaos mode
        
        let lastGameResult = null;

        // Game Statistics
        let gameStats = {
            gamesPlayed: 0,
            totalScore: 0,
            totalTime: 0,
            totalMoves: 0,
            totalMatches: 0,
            totalAttempts: 0,
            bestScore: 0,
            bestTime: null,
            bestMoves: null,
            bestCombo: 0,
            currentStreak: 0,
            bestStreak: 0,
            sessionGames: 0
        };

        // Current theme
        let currentTheme = 'purple';

        let currentRotation = 0;
        let score = 0;
        let combo = 0;
        let audioContext;
        let musicPlaying = false;
        let musicInterval;
        let musicGainNode;
        let sfxGainNode;
        let musicVolume = 0.5;
        let sfxVolume = 0.7;
        let backgroundOscillators = [];
        const comboMessages = [
            '',
            'Nice!',
            'Good Job!',
            'Great!',
            'Awesome!',
            'Fantastic!',
            'Amazing!',
            'Incredible!',
            'Unbelievable!',
            'Spectacular!',
            'Phenomenal!',
            'Legendary!',
            'Godlike!',
            'UNSTOPPABLE!',
            'MONSTER!',
            'BEYOND GODLIKE!'
        ];

        function applyDimensions() {
            const width = parseInt(document.getElementById('boardWidth').value);
            const height = parseInt(document.getElementById('boardHeight').value);
            const errorMsg = document.getElementById('errorMessage');
            
            if (width < 2 || height < 2) {
                errorMsg.textContent = 'Width and height must be at least 2!';
                errorMsg.classList.add('show');
                return;
            }
            
            const totalCards = width * height;
            
            // Check if total cards is odd
            if (totalCards % 2 !== 0) {
                errorMsg.textContent = 'Width Ã— Height must be an even number for matching pairs!';
                errorMsg.classList.add('show');
                return;
            }
            
            errorMsg.classList.remove('show');
            boardWidth = width;
            boardHeight = height;
            
            const pairsNeeded = totalCards / 2;
            const availableIcons = iconSets[currentIconSet];
            
            // Create pairs - reuse icons if needed
            emojis = [];
            for (let i = 0; i < pairsNeeded; i++) {
                emojis.push(availableIcons[i % availableIcons.length]);
            }
            
            resetGame();
        }

        function setIconSet(setName) {
            currentIconSet = setName;
            
            const buttons = document.querySelectorAll('.icon-set-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const activeIndex = ['gaming', 'animals', 'food', 'sports', 'nature', 'numbers', 'horoscope', 'custom'].indexOf(setName);
            if (activeIndex >= 0) {
                buttons[activeIndex].classList.add('active');
            }
            
            const customInput = document.getElementById('customInput');
            if (setName === 'custom') {
                customInput.style.display = 'flex';
            } else {
                customInput.style.display = 'none';
                const pairsNeeded = (boardWidth * boardHeight) / 2;
                const availableIcons = iconSets[setName];
                
                // Create pairs - reuse icons if needed
                emojis = [];
                for (let i = 0; i < pairsNeeded; i++) {
                    emojis.push(availableIcons[i % availableIcons.length]);
                }
                
                resetGame();
            }
        }

        function applyCustomIcons() {
            const input = document.getElementById('customEmojis').value.trim();
            const customEmojis = input.split(/\s+/).filter(e => e.length > 0);
            
            const pairsNeeded = (boardWidth * boardHeight) / 2;
            
            if (customEmojis.length < pairsNeeded) {
                alert(`Please enter at least ${pairsNeeded} different emojis for a ${boardWidth}Ã—${boardHeight} board!`);
                return;
            }
            
            emojis = customEmojis.slice(0, pairsNeeded);
            resetGame();
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${boardWidth}, 1fr)`;
            
            cards = [...emojis, ...emojis];
            cards = shuffle(cards);
            
            cards.forEach((emoji, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.emoji = emoji;
                card.dataset.index = index;
                card.innerHTML = `
                    <div class="card-face card-back"></div>
                    <div class="card-face card-front">${emoji}</div>
                `;
                card.addEventListener('click', flipCard);

                // Add touch event support for mobile
                card.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    flipCard.call(card);
                }, { passive: false });

                // Prevent context menu on long press
                card.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                board.appendChild(card);
            });
        }

        function flipCard() {
            if (!canFlip) return;
            if (this.classList.contains('flipped') || this.classList.contains('matched')) return;
            if (flippedCards.length >= 2) return;
            if (flippedCards.includes(this)) return;

            playFlipSound();
            
            this.classList.add('flipped');
            flippedCards.push(this);
            
            // Track reveal time for Memory Fade mode
            if (gameMode === 'fade' && !cardRevealTimes.has(this)) {
                cardRevealTimes.set(this, Date.now());
                startCardFade(this);
            }

            // Fortune Teller Mode - Show hint on first card
            if (gameMode === 'fortune' && flippedCards.length === 1) {
                showFortuneHint(this);
            }

            if (flippedCards.length === 2) {
                moves++;
                document.getElementById('moves').textContent = moves;
                checkMatch();
            }
        }

        function showFortuneHint(firstCard) {
            const firstEmoji = firstCard.dataset.emoji;
            
            // Find the matching card
            const allCards = Array.from(document.querySelectorAll('.card'));
            const matchingCard = allCards.find(card => 
                card !== firstCard && 
                card.dataset.emoji === firstEmoji && 
                !card.classList.contains('matched')
            );
            
            if (!matchingCard) return;
            
            // Get positions
            const firstIndex = allCards.indexOf(firstCard);
            const matchIndex = allCards.indexOf(matchingCard);
            
            // Calculate distance (in terms of grid positions)
            const firstRow = Math.floor(firstIndex / boardWidth);
            const firstCol = firstIndex % boardWidth;
            const matchRow = Math.floor(matchIndex / boardWidth);
            const matchCol = matchIndex % boardWidth;
            
            const rowDiff = Math.abs(matchRow - firstRow);
            const colDiff = Math.abs(matchCol - firstCol);
            const distance = Math.max(rowDiff, colDiff); // Chebyshev distance
            
            // Show hint based on distance
            let hintMessage = '';
            if (distance <= 1) {
                hintMessage = 'ğŸ”® The spirits whisper: "Very close, right beside you..."';
                matchingCard.classList.add('hint-glow');
                setTimeout(() => matchingCard.classList.remove('hint-glow'), 1500);
            } else if (distance <= 2) {
                hintMessage = 'ğŸ”® The spirits whisper: "Nearby, within reach..."';
            } else if (distance <= 3) {
                hintMessage = 'ğŸ”® The spirits whisper: "Not too far, search around..."';
            } else {
                hintMessage = 'ğŸ”® The spirits whisper: "Far across the realm..."';
            }
            
            // Show message
            const messageEl = document.getElementById('fortuneMessage');
            messageEl.textContent = hintMessage;
            messageEl.classList.add('show');
            
            setTimeout(() => {
                messageEl.classList.remove('show');
            }, 2000);
        }

        function startCardFade(card) {
            // Start fading after 3 seconds of being revealed
            setTimeout(() => {
                if (!card.classList.contains('matched')) {
                    card.classList.add('fading');
                }
            }, 3000);
        }

        function showComboMessage(message) {
            // Remove any existing combo message
            const existingMsg = document.querySelector('.combo-message');
            if (existingMsg) {
                existingMsg.remove();
            }
            
            // Create and show new message
            const msgElement = document.createElement('div');
            msgElement.className = 'combo-message';
            msgElement.textContent = message;
            document.body.appendChild(msgElement);
            
            // Remove after animation
            setTimeout(() => {
                msgElement.remove();
            }, 1000);
        }

        function checkMatch() {
            canFlip = false;
            const [card1, card2] = flippedCards;
            const emoji1 = card1.dataset.emoji;
            const emoji2 = card2.dataset.emoji;

            // Track attempt
            gameStats.totalAttempts++;

            if (emoji1 === emoji2) {
                setTimeout(() => {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    card1.classList.remove('fading'); // Remove fade effect on match
                    card2.classList.remove('fading');
                    matchedPairs++;
                    
                    // Track match
                    gameStats.totalMatches++;
                    
                    // Increase combo and calculate score
                    combo++;
                    const points = 100 * combo;
                    score += points;
                    
                    // Track best combo
                    if (combo > gameStats.bestCombo) {
                        gameStats.bestCombo = combo;
                    }
                    
                    // Update displays
                    document.getElementById('score').textContent = score;
                    document.getElementById('combo').textContent = combo;
                    
                    // Show combo message
                    if (combo >= 2 && combo < comboMessages.length) {
                        showComboMessage(comboMessages[combo]);
                    } else if (combo >= comboMessages.length) {
                        showComboMessage(comboMessages[comboMessages.length - 1]);
                    }
                    
                    // Add pulse animation to combo box
                    const comboBox = document.getElementById('comboBox');
                    if (combo > 1) {
                        comboBox.classList.add('active');
                    }
                    
                    flippedCards = [];
                    canFlip = true;

                    const totalPairs = (boardWidth * boardHeight) / 2;
                    if (matchedPairs === totalPairs) {
                        winGame();
                    }
                }, 500);
            } else {
                setTimeout(() => {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                    // Only remove fading in fade mode if it's not time yet
                    if (gameMode !== 'fade') {
                        card1.classList.remove('fading');
                        card2.classList.remove('fading');
                    }
                    
                    // Reset combo on miss
                    combo = 0;
                    document.getElementById('combo').textContent = combo;
                    document.getElementById('comboBox').classList.remove('active');
                    
                    if (gameMode === 'chaos') {
                        randomizeCards();
                    } else if (gameMode === 'swap') {
                        swapCards(card1, card2);
                    } else if (gameMode === 'rotate') {
                        rotateDeck();
                    }
                    
                    flippedCards = [];
                    canFlip = true;
                }, 1000);
            }
        }

        function randomizeCards() {
            const board = document.getElementById('gameBoard');
            const allCards = Array.from(document.querySelectorAll('.card'));
            
            playShuffleSound();
            
            const unmatchedData = [];
            
            allCards.forEach((card, index) => {
                if (!card.classList.contains('matched')) {
                    unmatchedData.push({
                        index: index,
                        emoji: cards[index],
                        card: card
                    });
                }
            });
            
            const shuffledEmojis = shuffle([...unmatchedData.map(d => d.emoji)]);
            
            const movements = [];
            unmatchedData.forEach((data, i) => {
                const oldIndex = data.index;
                const oldEmoji = data.emoji;
                const newEmoji = shuffledEmojis[i];
                
                const sourceIndex = unmatchedData.find(d => d.emoji === newEmoji).index;
                
                movements.push({
                    card: data.card,
                    oldIndex: oldIndex,
                    sourceIndex: sourceIndex,
                    newEmoji: newEmoji
                });
            });
            
            const positions = allCards.map(card => {
                const rect = card.getBoundingClientRect();
                return { x: rect.left, y: rect.top };
            });
            
            movements.forEach(movement => {
                const deltaX = positions[movement.sourceIndex].x - positions[movement.oldIndex].x;
                const deltaY = positions[movement.sourceIndex].y - positions[movement.oldIndex].y;
                
                movement.card.classList.add('animating');
                movement.card.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            });
            
            setTimeout(() => {
                movements.forEach(movement => {
                    cards[movement.oldIndex] = movement.newEmoji;
                    const front = movement.card.querySelector('.card-front');
                    front.textContent = movement.newEmoji;
                    movement.card.dataset.emoji = movement.newEmoji;
                    
                    movement.card.classList.remove('animating');
                    movement.card.style.transform = '';
                });
            }, 800);
        }

        function swapCards(card1, card2) {
            playSwapSound();
            
            const allCards = document.querySelectorAll('.card');
            const index1 = Array.from(allCards).indexOf(card1);
            const index2 = Array.from(allCards).indexOf(card2);
            
            [cards[index1], cards[index2]] = [cards[index2], cards[index1]];
            
            const front1 = card1.querySelector('.card-front');
            const front2 = card2.querySelector('.card-front');
            
            front1.textContent = cards[index1];
            front2.textContent = cards[index2];
            
            card1.dataset.emoji = cards[index1];
            card2.dataset.emoji = cards[index2];
        }

        function rotateDeck() {
            playRotateSound();
            
            const board = document.getElementById('gameBoard');
            const allCards = document.querySelectorAll('.card');
            
            // Check if board is very rectangular (aspect ratio around 1:2 or 2:1)
            const aspectRatio = boardWidth / boardHeight;
            const isVeryRectangular = aspectRatio <= 0.6 || aspectRatio >= 1.7;
            
            // If very rectangular, only allow 180 and 360 degree rotations
            const rotations = isVeryRectangular ? [180, 360] : [90, 180, 270, 360];
            
            const direction = Math.random() < 0.5 ? 1 : -1;
            const rotationAmount = rotations[Math.floor(Math.random() * rotations.length)];
            
            currentRotation += (rotationAmount * direction);
            board.style.transform = `rotate(${currentRotation}deg)`;
            
            allCards.forEach(card => {
                const faces = card.querySelectorAll('.card-face');
                faces.forEach(face => {
                    face.style.transform = face.classList.contains('card-front') 
                        ? `rotateY(180deg) rotate(${-currentRotation}deg)`
                        : `rotate(${-currentRotation}deg)`;
                });
            });
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                timer++;
                document.getElementById('timer').textContent = timer;
            }, 1000);
        }

        function winGame() {
            clearInterval(timerInterval);
            
            // Calculate time bonus
            const totalPairs = (boardWidth * boardHeight) / 2;
            const averageTimePerPair = timer / totalPairs;
            let timeBonus = 0;
            
            // Faster completion = higher bonus
            if (averageTimePerPair < 2) {
                timeBonus = 5000; // Lightning fast!
            } else if (averageTimePerPair < 3) {
                timeBonus = 3000; // Very fast
            } else if (averageTimePerPair < 5) {
                timeBonus = 2000; // Fast
            } else if (averageTimePerPair < 8) {
                timeBonus = 1000; // Good
            } else if (averageTimePerPair < 12) {
                timeBonus = 500; // Decent
            }
            
            const finalScore = score + timeBonus;
            
            // Update statistics
            gameStats.gamesPlayed++;
            gameStats.totalScore += finalScore;
            gameStats.sessionGames++;
            gameStats.totalTime += timer;
            gameStats.totalMoves += moves;
            gameStats.currentStreak++;
            
            // Update best stats
            if (finalScore > gameStats.bestScore) {
                gameStats.bestScore = finalScore;
            }
            if (gameStats.bestTime === null || timer < gameStats.bestTime) {
                gameStats.bestTime = timer;
            }
            if (gameStats.bestMoves === null || moves < gameStats.bestMoves) {
                gameStats.bestMoves = moves;
            }
            if (gameStats.currentStreak > gameStats.bestStreak) {
                gameStats.bestStreak = gameStats.currentStreak;
            }
            
            // Check achievement-specific conditions
            const gridSize = `${boardWidth}x${boardHeight}`;
            
            // Store game result temporarily
            lastGameResult = {
                score: finalScore,
                time: timer,
                moves: moves,
                gridSize: gridSize,
                gameMode: gameMode,
                totalCards: boardWidth * boardHeight,
                date: new Date().toISOString(),
                timeBonus: timeBonus
            };
            
            // Show name input modal
            document.getElementById('modalOverlay').classList.add('show');
            document.getElementById('nameInputModal').classList.add('show');
            document.getElementById('playerNameInput').value = '';
            document.getElementById('playerNameInput').focus();
            
            // Allow Enter key to submit
            document.getElementById('playerNameInput').onkeypress = function(e) {
                if (e.key === 'Enter') {
                    submitScore();
                }
            };
        }

        function submitScore() {
            const nameInput = document.getElementById('playerNameInput');
            let playerName = nameInput.value.trim();
            
            // Default name if empty
            if (!playerName) {
                playerName = 'Anonymous';
            }
            
            // Add name to the game result
            lastGameResult.name = playerName;

            // Save to global leaderboard in localStorage
            try {
                // Get existing scores
                let cardFlipScores = [];
                const existingData = localStorage.getItem('cardFlipScores');
                if (existingData) {
                    cardFlipScores = JSON.parse(existingData);
                }

                // Add new score
                cardFlipScores.push({
                    name: lastGameResult.name,
                    score: lastGameResult.score,
                    date: lastGameResult.date
                });

                // Sort by score (descending)
                cardFlipScores.sort((a, b) => b.score - a.score);

                // Keep only top 100 scores
                cardFlipScores = cardFlipScores.slice(0, 100);

                // Save back to localStorage
                localStorage.setItem('cardFlipScores', JSON.stringify(cardFlipScores));
            } catch (e) {
                console.error('Failed to save score to localStorage:', e);
            }

            // Hide name input modal
            document.getElementById('modalOverlay').classList.remove('show');
            document.getElementById('nameInputModal').classList.remove('show');
            
            // Show win message
            document.getElementById('finalScore').textContent = lastGameResult.score + (lastGameResult.timeBonus > 0 ? ` (+ ${lastGameResult.timeBonus} time bonus!)` : '');
            document.getElementById('finalMoves').textContent = lastGameResult.moves;
            document.getElementById('finalTime').textContent = lastGameResult.time;
            document.getElementById('winMessage').classList.add('show');
        }


        // Statistics Functions
        function toggleStats() {
            const panel = document.getElementById('statsPanel');
            const isShowing = panel.classList.contains('show');

            // Close all other panels
            document.getElementById('settingsPanel').classList.remove('open');

            // Toggle this panel
            panel.classList.toggle('show');
            if (!isShowing) {
                updateStatisticsDisplay();
            }
        }

        function updateStatisticsDisplay() {
            // Main stats cards
            document.getElementById('statGamesPlayed').textContent = gameStats.gamesPlayed;
            
            const avgScore = gameStats.gamesPlayed > 0 
                ? Math.round(gameStats.totalScore / gameStats.gamesPlayed) 
                : 0;
            document.getElementById('statAvgScore').textContent = avgScore;
            
            document.getElementById('statBestScore').textContent = gameStats.bestScore;
            
            const totalMinutes = Math.floor(gameStats.totalTime / 60);
            document.getElementById('statTotalTime').textContent = totalMinutes + 'm';
            
            // Performance stats
            const avgTime = gameStats.gamesPlayed > 0 
                ? Math.round(gameStats.totalTime / gameStats.gamesPlayed) 
                : 0;
            document.getElementById('statAvgTime').textContent = avgTime + 's';
            
            const avgMoves = gameStats.gamesPlayed > 0 
                ? Math.round(gameStats.totalMoves / gameStats.gamesPlayed) 
                : 0;
            document.getElementById('statAvgMoves').textContent = avgMoves;
            
            document.getElementById('statBestTime').textContent = 
                gameStats.bestTime !== null ? gameStats.bestTime + 's' : '--';
            
            document.getElementById('statBestMoves').textContent = 
                gameStats.bestMoves !== null ? gameStats.bestMoves : '--';
            
            // Accuracy stats
            document.getElementById('statTotalMatches').textContent = gameStats.totalMatches;
            document.getElementById('statTotalAttempts').textContent = gameStats.totalAttempts;
            
            const accuracy = gameStats.totalAttempts > 0 
                ? Math.round((gameStats.totalMatches / gameStats.totalAttempts) * 100) 
                : 0;
            document.getElementById('statAccuracy').textContent = accuracy + '%';
            
            document.getElementById('statBestCombo').textContent = gameStats.bestCombo;
            
            // Session stats
            document.getElementById('statSessionGames').textContent = gameStats.sessionGames;
            document.getElementById('statWinStreak').textContent = gameStats.currentStreak;
            document.getElementById('statBestStreak').textContent = gameStats.bestStreak;
        }

        function resetStatistics() {
            if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
                gameStats = {
                    gamesPlayed: 0,
                    totalScore: 0,
                    totalTime: 0,
                    totalMoves: 0,
                    totalMatches: 0,
                    totalAttempts: 0,
                    bestScore: 0,
                    bestTime: null,
                    bestMoves: null,
                    bestCombo: 0,
                    currentStreak: 0,
                    bestStreak: 0,
                    sessionGames: 0
                };
                updateStatisticsDisplay();
            }
        }

        // Theme Functions
        function setTheme(theme) {
            // Remove all theme classes
            document.body.className = document.body.className.replace(/theme-\w+/g, '').trim();
            
            // Add new theme class
            document.body.classList.add('theme-' + theme);
            
            // Update button states
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            currentTheme = theme;
            
        }


        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            const isOpen = panel.classList.contains('open');

            // Close all other panels
            document.getElementById('statsPanel').classList.remove('show');

            // Toggle this panel
            panel.classList.toggle('open');
        }

        // Music System
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create master gain nodes
                musicGainNode = audioContext.createGain();
                sfxGainNode = audioContext.createGain();
                
                musicGainNode.gain.value = musicVolume;
                sfxGainNode.gain.value = sfxVolume;
                
                musicGainNode.connect(audioContext.destination);
                sfxGainNode.connect(audioContext.destination);
            }
        }

        function updateMusicVolume(value) {
            musicVolume = value / 100;
            document.getElementById('musicVolumeDisplay').textContent = value + '%';
            if (musicGainNode) {
                musicGainNode.gain.value = musicVolume;
            }
            
            // Auto-start music if volume is turned up from 0
            if (value > 0 && !musicPlaying) {
                startMusic();
            } else if (value == 0 && musicPlaying) {
                stopMusic();
            }
        }

        function updateSFXVolume(value) {
            sfxVolume = value / 100;
            document.getElementById('sfxVolumeDisplay').textContent = value + '%';
            if (sfxGainNode) {
                sfxGainNode.gain.value = sfxVolume;
            }
        }

        function playFlipSound() {
            if (sfxVolume === 0) return;
            initAudio();
            const now = audioContext.currentTime;
            
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.15, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            osc.connect(gainNode);
            gainNode.connect(sfxGainNode);
            
            osc.start(now);
            osc.stop(now + 0.15);
        }

        function playShuffleSound() {
            if (sfxVolume === 0) return;
            initAudio();
            const now = audioContext.currentTime;
            
            // Create a "whoosh" sound for shuffling
            for (let i = 0; i < 5; i++) {
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                const startFreq = 400 + Math.random() * 400;
                osc.frequency.setValueAtTime(startFreq, now + i * 0.05);
                osc.frequency.exponentialRampToValueAtTime(200, now + i * 0.05 + 0.1);
                
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0.08, now + i * 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.1);
                
                osc.connect(gainNode);
                gainNode.connect(sfxGainNode);
                
                osc.start(now + i * 0.05);
                osc.stop(now + i * 0.05 + 0.1);
            }
        }

        function playSwapSound() {
            if (sfxVolume === 0) return;
            initAudio();
            const now = audioContext.currentTime;
            
            // Create a "switch" sound - two tones crossing paths
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            
            osc1.type = 'sine';
            osc2.type = 'sine';
            
            // First tone goes from high to low
            osc1.frequency.setValueAtTime(800, now);
            osc1.frequency.exponentialRampToValueAtTime(400, now + 0.2);
            
            // Second tone goes from low to high
            osc2.frequency.setValueAtTime(400, now);
            osc2.frequency.exponentialRampToValueAtTime(800, now + 0.2);
            
            const gainNode1 = audioContext.createGain();
            const gainNode2 = audioContext.createGain();
            
            gainNode1.gain.setValueAtTime(0.1, now);
            gainNode1.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
            
            gainNode2.gain.setValueAtTime(0.1, now);
            gainNode2.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
            
            osc1.connect(gainNode1);
            osc2.connect(gainNode2);
            gainNode1.connect(sfxGainNode);
            gainNode2.connect(sfxGainNode);
            
            osc1.start(now);
            osc2.start(now);
            osc1.stop(now + 0.25);
            osc2.stop(now + 0.25);
        }

        function playRotateSound() {
            if (sfxVolume === 0) return;
            initAudio();
            const now = audioContext.currentTime;
            
            // Create a spinning/whoosh sound with multiple oscillators
            const frequencies = [300, 450, 600, 750];
            
            frequencies.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                
                const delay = i * 0.08;
                osc.frequency.setValueAtTime(freq, now + delay);
                osc.frequency.exponentialRampToValueAtTime(freq * 0.7, now + delay + 0.3);
                
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, now + delay);
                gainNode.gain.linearRampToValueAtTime(0.08, now + delay + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.3);
                
                // Add panning for rotation effect
                const panner = audioContext.createStereoPanner();
                panner.pan.setValueAtTime(-1 + (i / frequencies.length) * 2, now + delay);
                panner.pan.linearRampToValueAtTime(1 - (i / frequencies.length) * 2, now + delay + 0.3);
                
                osc.connect(gainNode);
                gainNode.connect(panner);
                panner.connect(sfxGainNode);
                
                osc.start(now + delay);
                osc.stop(now + delay + 0.3);
            });
        }

        function createBackgroundDrone() {
            // Removed - no background drone, just melody
        }

        function playMarimbaTone(frequency, duration, delay = 0) {
            initAudio();
            const now = audioContext.currentTime + delay;
            
            // Create oscillators for rich marimba-like sound
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const osc3 = audioContext.createOscillator();
            
            osc1.type = 'sine';
            osc2.type = 'sine';
            osc3.type = 'sine';
            osc1.frequency.value = frequency;
            osc2.frequency.value = frequency * 2; // Octave
            osc3.frequency.value = frequency * 3; // Fifth
            
            const gainNode1 = audioContext.createGain();
            const gainNode2 = audioContext.createGain();
            const gainNode3 = audioContext.createGain();
            
            // Softer attack and decay
            gainNode1.gain.setValueAtTime(0, now);
            gainNode1.gain.linearRampToValueAtTime(0.08, now + 0.05);
            gainNode1.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            gainNode2.gain.setValueAtTime(0, now);
            gainNode2.gain.linearRampToValueAtTime(0.04, now + 0.05);
            gainNode2.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            gainNode3.gain.setValueAtTime(0, now);
            gainNode3.gain.linearRampToValueAtTime(0.02, now + 0.05);
            gainNode3.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            // Add a low-pass filter for smoothness
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 3000;
            filter.Q.value = 1;
            
            osc1.connect(gainNode1);
            osc2.connect(gainNode2);
            osc3.connect(gainNode3);
            
            gainNode1.connect(filter);
            gainNode2.connect(filter);
            gainNode3.connect(filter);
            filter.connect(musicGainNode);
            
            osc1.start(now);
            osc2.start(now);
            osc3.start(now);
            osc1.stop(now + duration);
            osc2.stop(now + duration);
            osc3.stop(now + duration);
        }

        function playPercussion(delay = 0) {
            initAudio();
            const now = audioContext.currentTime + delay;
            
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(80, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.08);
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.05, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
            
            osc.connect(gainNode);
            gainNode.connect(musicGainNode);
            
            osc.start(now);
            osc.stop(now + 0.08);
        }

        function playMusicLoop() {
            if (!musicPlaying) return;
            
            const bpm = 95;
            const beatDuration = 60 / bpm; // ~0.632 seconds per beat
            const barDuration = beatDuration * 4;
            
            // INTRO - 4 bars (Cm pad â†’ Ab pad with arpeggio)
            // Pad: Cm chord (C-Eb-G)
            playPadChord([261.63, 311.13, 392.00], 1.5, 0, barDuration * 2);
            // Pad: Ab chord (Ab-C-Eb)
            playPadChord([415.30, 261.63, 311.13], 1.5, barDuration * 2, barDuration * 2);
            
            // Lead arpeggio over intro
            const introArp = [523.25, 622.25, 783.99, 932.33, 1046.50, 932.33, 783.99, 622.25]; // C5 Eb5 G5 Bb5 C6 Bb5 G5 Eb5
            introArp.forEach((note, i) => {
                playLeadNote(note, 0.5, i * beatDuration * 0.5);
            });
            
            // Bass notes (intro)
            playBassNote(130.81, 0.5, 0);                    // C2
            playBassNote(130.81, 0.5, beatDuration);          // C2
            playBassNote(155.56, 0.5, beatDuration * 2);     // Eb2
            playBassNote(116.54, 0.5, beatDuration * 3);     // Bb1
            
            // MAIN LOOP - 8 bars (starting at bar 5)
            const mainStart = barDuration * 4;
            
            // Chords: Cm - Ab - Eb - Bb | Cm - Gm - Ab - Bb
            const chords = [
                { notes: [261.63, 311.13, 392.00], delay: mainStart },                     // Cm
                { notes: [415.30, 261.63, 311.13], delay: mainStart + barDuration },       // Ab
                { notes: [311.13, 392.00, 466.16], delay: mainStart + barDuration * 2 },   // Eb
                { notes: [466.16, 293.66, 349.23], delay: mainStart + barDuration * 3 },   // Bb
                { notes: [261.63, 311.13, 392.00], delay: mainStart + barDuration * 4 },   // Cm
                { notes: [392.00, 233.08, 293.66], delay: mainStart + barDuration * 5 },   // Gm
                { notes: [415.30, 261.63, 311.13], delay: mainStart + barDuration * 6 },   // Ab
                { notes: [466.16, 293.66, 349.23], delay: mainStart + barDuration * 7 }    // Bb
            ];
            
            chords.forEach(chord => {
                playPadChord(chord.notes, 1.0, chord.delay, barDuration);
            });
            
            // Melody pattern
            const melody = [
                523.25, 622.25, 783.99, 830.61,  // C5 Eb5 G5 Ab5
                932.33, 830.61, 783.99, 622.25,  // Bb5 Ab5 G5 Eb5
                523.25, 783.99, 830.61, 932.33,  // C5 G5 Ab5 Bb5
                783.99, 698.46, 622.25, 523.25   // G5 F5 Eb5 C5
            ];
            
            melody.forEach((note, i) => {
                playLeadNote(note, 0.35, mainStart + i * beatDuration * 0.5);
            });
            
            // Bass pattern (root-root-5th-root)
            const bassPattern = [
                { note: 130.81, beats: [0, 1, 3] },      // Cm: C-C-G-C
                { note: 207.65, beats: [0, 1, 3] },      // Ab: Ab-Ab-Eb-Ab
                { note: 155.56, beats: [0, 1, 3] },      // Eb
                { note: 233.08, beats: [0, 1, 3] },      // Bb
                { note: 130.81, beats: [0, 1, 3] },      // Cm
                { note: 196.00, beats: [0, 1, 3] },      // Gm
                { note: 207.65, beats: [0, 1, 3] },      // Ab
                { note: 233.08, beats: [0, 1, 3] }       // Bb
            ];
            
            bassPattern.forEach((pattern, bar) => {
                pattern.beats.forEach(beat => {
                    const delay = mainStart + bar * barDuration + beat * beatDuration;
                    playBassNote(pattern.note, 0.4, delay);
                });
                // 5th on beat 2
                playBassNote(pattern.note * 1.5, 0.4, mainStart + bar * barDuration + 2 * beatDuration);
            });
            
            // Drums
            for (let i = 0; i < 8; i++) {
                const barStart = mainStart + i * barDuration;
                // Kick on 1 & 3
                playKick(barStart);
                playKick(barStart + beatDuration * 2);
                // Snare on 2 & 4
                playSnare(barStart + beatDuration);
                playSnare(barStart + beatDuration * 3);
                // Hi-hat every 1/8 note
                for (let j = 0; j < 8; j++) {
                    playHiHat(barStart + j * beatDuration * 0.5);
                }
            }
        }

        function playPadChord(frequencies, volume, delay, duration) {
            if (!musicPlaying) return;
            initAudio();
            const now = audioContext.currentTime + delay;
            
            frequencies.forEach(freq => {
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.02, now + 0.1);
                gainNode.gain.setValueAtTime(volume * 0.02, now + duration - 0.2);
                gainNode.gain.linearRampToValueAtTime(0.001, now + duration);
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                
                osc.connect(gainNode);
                gainNode.connect(filter);
                filter.connect(musicGainNode);
                
                osc.start(now);
                osc.stop(now + duration);
            });
        }

        function playLeadNote(frequency, duration, delay) {
            if (!musicPlaying) return;
            initAudio();
            const now = audioContext.currentTime + delay;
            
            const osc = audioContext.createOscillator();
            osc.type = 'square';
            osc.frequency.value = frequency;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.04, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 3000;
            
            osc.connect(gainNode);
            gainNode.connect(filter);
            filter.connect(musicGainNode);
            
            osc.start(now);
            osc.stop(now + duration);
        }

        function playBassNote(frequency, duration, delay) {
            if (!musicPlaying) return;
            initAudio();
            const now = audioContext.currentTime + delay;
            
            const osc = audioContext.createOscillator();
            osc.type = 'triangle';
            osc.frequency.value = frequency;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.08, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            
            osc.connect(gainNode);
            gainNode.connect(filter);
            filter.connect(musicGainNode);
            
            osc.start(now);
            osc.stop(now + duration);
        }

        function playKick(delay) {
            if (!musicPlaying) return;
            initAudio();
            const now = audioContext.currentTime + delay;
            
            const osc = audioContext.createOscillator();
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.15, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            
            osc.connect(gainNode);
            gainNode.connect(musicGainNode);
            
            osc.start(now);
            osc.stop(now + 0.15);
        }

        function playSnare(delay) {
            if (!musicPlaying) return;
            initAudio();
            const now = audioContext.currentTime + delay;
            
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.08, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 1000;
            
            noise.connect(gainNode);
            gainNode.connect(filter);
            filter.connect(musicGainNode);
            
            noise.start(now);
        }

        function playHiHat(delay) {
            if (!musicPlaying) return;
            initAudio();
            const now = audioContext.currentTime + delay;
            
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.02, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 5000;
            
            noise.connect(gainNode);
            gainNode.connect(filter);
            filter.connect(musicGainNode);
            
            noise.start(now);
        }

        function startMusic() {
            if (musicPlaying || musicVolume === 0) return;
            
            initAudio();
            musicPlaying = true;
            
            // Play immediately and loop every 10 seconds for natural breathing
            playMusicLoop();
            musicInterval = setInterval(() => {
                if (musicPlaying) {
                    playMusicLoop();
                }
            }, 10000);
        }

        function stopMusic() {
            musicPlaying = false;
            clearInterval(musicInterval);
        }

        function toggleMusic() {
            if (musicPlaying) {
                stopMusic();
            } else {
                startMusic();
            }
        }

        function setMode(mode) {
            gameMode = mode;
            document.getElementById('modeSelect').value = mode;
            // Reset game to apply new mode
            resetGame();
        }

        function resetGame() {
            clearInterval(timerInterval);
            flippedCards = [];
            matchedPairs = 0;
            moves = 0;
            timer = 0;
            canFlip = true;
            currentRotation = 0;
            score = 0;
            combo = 0;
            cardRevealTimes.clear(); // Clear fade tracking
            
            document.getElementById('moves').textContent = '0';
            document.getElementById('timer').textContent = '0';
            document.getElementById('score').textContent = '0';
            document.getElementById('combo').textContent = '0';
            document.getElementById('comboBox').classList.remove('active');
            document.getElementById('winMessage').classList.remove('show');
            
            const board = document.getElementById('gameBoard');
            board.style.transform = 'rotate(0deg)';
            
            createBoard();
            
            const allCards = document.querySelectorAll('.card');
            allCards.forEach(card => {
                const faces = card.querySelectorAll('.card-face');
                faces.forEach(face => {
                    if (face.classList.contains('card-front')) {
                        face.style.transform = 'rotateY(180deg)';
                    } else {
                        face.style.transform = 'rotate(0deg)';
                    }
                });
                card.classList.remove('fading'); // Remove any fade effects
            });
            
            // Stop color chaos if running
            stopColorChaos();
            
            // Check if Peek Mode is active
            if (gameMode === 'peek') {
                startPeekMode();
            } else {
                startTimer();
                
                // Start color chaos if in that mode
                if (gameMode === 'color') {
                    startColorChaos();
                }
            }
            
            // Auto-start music if volume is set
            if (musicVolume > 0 && !musicPlaying) {
                startMusic();
            }
        }

        function startPeekMode() {
            // Show all cards face-up
            canFlip = false;
            const allCards = document.querySelectorAll('.card');
            allCards.forEach(card => {
                card.classList.add('flipped');
            });
            
            // Show peek overlay with countdown
            const overlay = document.getElementById('peekOverlay');
            const timerEl = document.getElementById('peekTimer');
            overlay.classList.add('show');
            
            let peekTime = 5;
            timerEl.textContent = peekTime;
            
            const peekInterval = setInterval(() => {
                peekTime--;
                timerEl.textContent = peekTime;
                
                if (peekTime <= 0) {
                    clearInterval(peekInterval);
                    endPeekMode();
                }
            }, 1000);
        }

        function endPeekMode() {
            // Hide overlay
            document.getElementById('peekOverlay').classList.remove('show');
            
            // Flip all cards back
            const allCards = document.querySelectorAll('.card');
            allCards.forEach(card => {
                if (!card.classList.contains('matched')) {
                    card.classList.remove('flipped');
                }
            });
            
            // Enable clicking and start timer
            canFlip = true;
            startTimer();
        }

        function startColorChaos() {
            // Change card back colors every 5 seconds
            colorShiftInterval = setInterval(() => {
                const allCards = document.querySelectorAll('.card');
                allCards.forEach(card => {
                    if (!card.classList.contains('matched')) {
                        card.classList.add('color-shift');
                        shiftCardColor(card);
                    }
                });
            }, 5000);
        }

        function shiftCardColor(card) {
            const colors = [
                'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                'linear-gradient(135deg, #30cfd0 0%, #330867 100%)',
                'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                'linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%)'
            ];
            
            const borderColors = [
                'white',
                'rgba(255, 255, 255, 0.9)',
                'rgba(255, 215, 0, 0.8)',
                'rgba(100, 255, 218, 0.8)',
                'rgba(255, 182, 193, 0.9)'
            ];
            
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const randomBorder = borderColors[Math.floor(Math.random() * borderColors.length)];
            
            const cardBack = card.querySelector('.card-back');
            if (cardBack) {
                cardBack.style.background = randomColor;
                cardBack.style.borderColor = randomBorder;
            }
        }

        function stopColorChaos() {
            if (colorShiftInterval) {
                clearInterval(colorShiftInterval);
                colorShiftInterval = null;
            }
        }

        createBoard();
        startTimer();
        
        // Auto-start music if volume is set
        if (musicVolume > 0) {
            startMusic();
        }
    </script>
</body>
</html>
