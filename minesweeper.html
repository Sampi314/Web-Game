<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper with Hearts</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Mobile optimizations */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            overscroll-behavior: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .hearts {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 20px;
            font-weight: bold;
            color: #e74c3c;
        }

        .heart-icon {
            font-size: 24px;
        }

        .heart-count {
            font-size: 18px;
        }

        .flags-counter {
            font-size: 18px;
            font-weight: bold;
            color: #e74c3c;
        }

        .timer {
            font-size: 18px;
            font-weight: bold;
            color: #3498db;
        }

        .coins {
            font-size: 18px;
            font-weight: bold;
            color: #f39c12;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            /* Ensure minimum touch target size */
            min-width: 44px;
            min-height: 44px;
        }

        .btn-new-game {
            background: #2ecc71;
            color: white;
        }

        .btn-new-game:hover {
            background: #27ae60;
            transform: translateY(-2px);
        }

        .btn-difficulty {
            background: #3498db;
            color: white;
        }

        .btn-difficulty:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-shop {
            background: #f39c12;
            color: white;
        }

        .btn-shop:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .btn-reset {
            background: #e74c3c;
            color: white;
        }

        .btn-reset:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn-leaderboard {
            background: #9b59b6;
            color: white;
        }

        .btn-leaderboard:hover {
            background: #8e44ad;
            transform: translateY(-2px);
        }

        .btn-sound {
            background: #16a085;
            color: white;
        }

        .btn-sound:hover {
            background: #138d75;
            transform: translateY(-2px);
        }

        .btn-sound.muted {
            background: #95a5a6;
        }

        .btn-sound.muted:hover {
            background: #7f8c8d;
        }

        .difficulty-info {
            text-align: center;
            margin-bottom: 15px;
            color: #666;
            font-weight: bold;
        }

        .board {
            display: inline-grid;
            gap: 2px;
            background: #bdc3c7;
            padding: 5px;
            border-radius: 10px;
            margin: 0 auto;
            display: grid;
        }

        .cell {
            width: 35px;
            height: 35px;
            background: #ecf0f1;
            border: 2px solid #bdc3c7;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.1s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            /* Increase touch target without changing visual size */
            position: relative;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            /* This creates a larger touch target (45x45px) */
        }

        .cell:hover:not(.revealed):not(.flagged) {
            background: #d5dbdb;
            transform: scale(0.95);
        }

        .cell.revealed {
            background: #fff;
            border-color: #ddd;
            cursor: default;
        }

        .cell:active:not(.revealed) {
            background: #bdc3c7;
            transform: scale(0.95);
        }

        .cell.flagged {
            background: #e74c3c;
            color: white;
        }

        .cell.mine {
            background: #e74c3c;
            color: white;
        }

        .cell.number-1 { color: #3498db; }
        .cell.number-2 { color: #2ecc71; }
        .cell.number-3 { color: #e74c3c; }
        .cell.number-4 { color: #9b59b6; }
        .cell.number-5 { color: #f39c12; }
        .cell.number-6 { color: #1abc9c; }
        .cell.number-7 { color: #34495e; }
        .cell.number-8 { color: #e67e22; }

        .cell.heart-tile {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .powerups {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .powerup {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 15px;
            background: white;
            border: 3px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .powerup:hover:not(.disabled) {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border-color: #3498db;
        }

        .powerup.active {
            border-color: #2ecc71;
            background: #e8f8f5;
            transform: scale(1.05);
        }

        .powerup.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f5f5f5;
        }

        .powerup-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .powerup-name {
            font-size: 11px;
            font-weight: bold;
            color: #555;
            margin-bottom: 3px;
        }

        .powerup-count {
            font-size: 14px;
            font-weight: bold;
            color: #3498db;
        }

        .board.powerup-active .cell:not(.revealed):not(.flagged):hover {
            background: #a8e6cf;
            cursor: crosshair;
        }

        .reveal-preview {
            outline: 3px dashed #2ecc71;
            outline-offset: -3px;
        }

        .shop-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1500;
        }

        .shop-modal.show {
            display: flex;
        }

        .shop-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .shop-content h2 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .shop-balance {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 20px;
        }

        .shop-items {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px solid #ddd;
        }

        .shop-item-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .shop-item-icon {
            font-size: 30px;
        }

        .shop-item-details {
            display: flex;
            flex-direction: column;
        }

        .shop-item-name {
            font-weight: bold;
            color: #333;
        }

        .shop-item-price {
            color: #f39c12;
            font-weight: bold;
        }

        .btn-buy {
            padding: 8px 16px;
            background: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-buy:hover:not(:disabled) {
            background: #27ae60;
            transform: scale(1.05);
        }

        .btn-buy:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .btn-close-shop {
            width: 100%;
            margin-top: 20px;
            padding: 12px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-close-shop:hover {
            background: #7f8c8d;
        }

        .game-over-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over-overlay.show {
            display: flex;
        }

        .game-over-message {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: bounceIn 0.5s ease;
        }

        .game-over-message h2 {
            font-size: 3em;
            margin-bottom: 20px;
        }

        .game-over-message.win h2 {
            color: #2ecc71;
        }

        .game-over-message.lose h2 {
            color: #e74c3c;
        }

        .game-over-message p {
            font-size: 1.2em;
            margin-bottom: 20px;
            color: #666;
        }

        .difficulty-selector {
            margin: 20px 0;
        }

        .difficulty-selector label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        .difficulty-selector select {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .board-container {
            display: flex;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üí£ Minesweeper</h1>
        
        <div class="game-info">
            <div class="hearts" id="hearts"></div>
            <div class="coins" id="coins">ü™ô 0</div>
            <div class="flags-counter" id="flags">üö© 10</div>
            <div class="timer" id="timer">‚è±Ô∏è 0s</div>
        </div>

        <div class="difficulty-info" id="difficultyInfo">Easy (8x8, 10 mines)</div>

        <div class="powerups" id="powerups">
            <div class="powerup" id="powerup-1x1" onclick="activatePowerUp('reveal1x1')">
                <div class="powerup-icon">üîç</div>
                <div class="powerup-name">Reveal 1x1</div>
                <div class="powerup-count" id="count-1x1">3</div>
            </div>
            <div class="powerup" id="powerup-2x2" onclick="activatePowerUp('reveal2x2')">
                <div class="powerup-icon">üîé</div>
                <div class="powerup-name">Reveal 2x2</div>
                <div class="powerup-count" id="count-2x2">2</div>
            </div>
            <div class="powerup" id="powerup-3x3" onclick="activatePowerUp('reveal3x3')">
                <div class="powerup-icon">üî≠</div>
                <div class="powerup-name">Reveal 3x3</div>
                <div class="powerup-count" id="count-3x3">1</div>
            </div>
        </div>

        <div style="text-align: center; margin-bottom: 15px; color: #555; font-size: 14px;">
            üí° Desktop: Click both buttons on a number to reveal surrounding cells<br>
            üì± Mobile: Long press to flag, tap numbers to reveal surrounding cells
        </div>

        <div class="controls">
            <button class="btn btn-new-game" onclick="newGame()">New Game</button>
            <button class="btn btn-shop" onclick="openShop()">Shop üõí</button>
            <button class="btn btn-difficulty" onclick="changeDifficulty()">Change Difficulty</button>
            <button class="btn btn-sound" id="soundToggle" onclick="toggleSound()">üîä Sound On</button>
            <button class="btn btn-leaderboard" onclick="window.location.href='leaderboard.html'">üèÜ View Leaderboard</button>
        </div>

        <div class="board-container">
            <div class="board" id="board"></div>
        </div>
    </div>

    <div class="shop-modal" id="shopModal">
        <div class="shop-content">
            <h2>üõí Power-Up Shop</h2>
            <div class="shop-balance">
                Your Balance: <span id="shopCoins">ü™ô 0</span>
            </div>
            <div class="shop-items">
                <div class="shop-item">
                    <div class="shop-item-info">
                        <div class="shop-item-icon">üîç</div>
                        <div class="shop-item-details">
                            <div class="shop-item-name">Reveal 1x1</div>
                            <div class="shop-item-price">ü™ô 10 coins</div>
                        </div>
                    </div>
                    <button class="btn-buy" onclick="buyPowerUp('reveal1x1')">Buy</button>
                </div>
                <div class="shop-item">
                    <div class="shop-item-info">
                        <div class="shop-item-icon">üîé</div>
                        <div class="shop-item-details">
                            <div class="shop-item-name">Reveal 2x2</div>
                            <div class="shop-item-price">ü™ô 25 coins</div>
                        </div>
                    </div>
                    <button class="btn-buy" onclick="buyPowerUp('reveal2x2')">Buy</button>
                </div>
                <div class="shop-item">
                    <div class="shop-item-info">
                        <div class="shop-item-icon">üî≠</div>
                        <div class="shop-item-details">
                            <div class="shop-item-name">Reveal 3x3</div>
                            <div class="shop-item-price">ü™ô 50 coins</div>
                        </div>
                    </div>
                    <button class="btn-buy" onclick="buyPowerUp('reveal3x3')">Buy</button>
                </div>
            </div>
            <button class="btn-close-shop" onclick="closeShop()">Close Shop</button>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-message" id="gameOverMessage">
            <h2 id="gameOverTitle"></h2>
            <p id="gameOverText"></p>
            <div class="difficulty-selector" id="difficultySelectorWin" style="display: none;">
                <label for="nextDifficulty">Choose difficulty for next game:</label>
                <select id="nextDifficulty">
                    <option value="0">Easy (8x8, 10 mines, ü™ô 50 reward)</option>
                    <option value="1">Medium (12x12, 25 mines, ü™ô 100 reward)</option>
                    <option value="2">Hard (16x16, 50 mines, ü™ô 200 reward)</option>
                </select>
            </div>
            <button class="btn btn-new-game" onclick="startNextGame()">Play Again</button>
        </div>
    </div>

    <script>
        // ===== SOUND SYSTEM USING WEB AUDIO API =====
        let audioContext = null;
        let soundEnabled = true;

        // Initialize audio context (must be done after user interaction)
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error('Web Audio API not supported', e);
                    soundEnabled = false;
                }
            }
        }

        // Load sound preference from localStorage
        function loadSoundPreference() {
            const savedPreference = localStorage.getItem('minesweeperSoundEnabled');
            if (savedPreference !== null) {
                soundEnabled = savedPreference === 'true';
            }
            updateSoundButton();
        }

        // Toggle sound on/off
        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('minesweeperSoundEnabled', soundEnabled);
            updateSoundButton();

            // Play a test sound when enabling
            if (soundEnabled) {
                initAudioContext();
                playClickSound();
            }
        }

        // Update sound button appearance
        function updateSoundButton() {
            const btn = document.getElementById('soundToggle');
            if (soundEnabled) {
                btn.textContent = 'üîä Sound On';
                btn.classList.remove('muted');
            } else {
                btn.textContent = 'üîá Sound Off';
                btn.classList.add('muted');
            }
        }

        // Play click/reveal sound (subtle click)
        function playClickSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(800, now);
            oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.05);

            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

            oscillator.start(now);
            oscillator.stop(now + 0.05);
        }

        // Play flag sound (soft pop)
        function playFlagSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(600, now);
            oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.08);

            gainNode.gain.setValueAtTime(0.15, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

            oscillator.start(now);
            oscillator.stop(now + 0.08);
        }

        // Play mine explosion sound
        function playExplosionSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;

            // Create noise buffer for explosion effect
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;

            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(2000, now);
            noiseFilter.frequency.exponentialRampToValueAtTime(50, now + 0.5);

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(0.3, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

            // Add a low frequency rumble
            const rumble = audioContext.createOscillator();
            rumble.frequency.setValueAtTime(80, now);
            rumble.frequency.exponentialRampToValueAtTime(20, now + 0.4);

            const rumbleGain = audioContext.createGain();
            rumbleGain.gain.setValueAtTime(0.2, now);
            rumbleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioContext.destination);

            rumble.connect(rumbleGain);
            rumbleGain.connect(audioContext.destination);

            noise.start(now);
            noise.stop(now + 0.5);
            rumble.start(now);
            rumble.stop(now + 0.4);
        }

        // Play win sound (victory fanfare)
        function playWinSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6

            notes.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(freq, now + index * 0.15);
                oscillator.type = 'triangle';

                gainNode.gain.setValueAtTime(0, now + index * 0.15);
                gainNode.gain.linearRampToValueAtTime(0.2, now + index * 0.15 + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + index * 0.15 + 0.3);

                oscillator.start(now + index * 0.15);
                oscillator.stop(now + index * 0.15 + 0.3);
            });
        }

        // Play power-up use sound (special magical sound)
        function playPowerUpSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const oscillator1 = audioContext.createOscillator();
            const oscillator2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator1.type = 'sine';
            oscillator2.type = 'sine';

            oscillator1.frequency.setValueAtTime(440, now);
            oscillator1.frequency.exponentialRampToValueAtTime(880, now + 0.2);

            oscillator2.frequency.setValueAtTime(554, now);
            oscillator2.frequency.exponentialRampToValueAtTime(1108, now + 0.2);

            gainNode.gain.setValueAtTime(0.15, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

            oscillator1.start(now);
            oscillator1.stop(now + 0.2);
            oscillator2.start(now);
            oscillator2.stop(now + 0.2);
        }

        // Play number reveal sound (variations based on number)
        function playNumberSound(number) {
            if (!soundEnabled || !audioContext || number === 0) return;

            const now = audioContext.currentTime;
            const baseFreq = 400 + (number * 100); // Higher pitch for higher numbers
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(baseFreq, now);
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.08, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

            oscillator.start(now);
            oscillator.stop(now + 0.1);
        }

        // ===== GAME VARIABLES =====
        let board = [];
        let revealed = [];
        let flagged = [];
        let mines = [];
        let gameOver = false;
        let gameWon = false;
        let hearts = 3;
        let maxHearts = 3;
        let rows = 8;
        let cols = 8;
        let mineCount = 10;
        let timerInterval;
        let seconds = 0;
        let firstClick = true;
        let mouseButtons = { left: false, right: false };
        let chordCell = null;
        let touchTimer = null;
        let touchStartPos = null;
        let longPressTriggered = false;
        let heartTiles = [];
        let powerUps = {
            reveal1x1: 3,
            reveal2x2: 2,
            reveal3x3: 1
        };
        let activePowerUp = null;
        let coins = 0;
        let shopPrices = {
            reveal1x1: 10,
            reveal2x2: 25,
            reveal3x3: 50
        };
        let difficulties = [
            { name: 'Easy', rows: 8, cols: 8, mines: 10, hearts: 3, heartTiles: 3, coinReward: 50 },
            { name: 'Medium', rows: 12, cols: 12, mines: 25, hearts: 4, heartTiles: 5, coinReward: 100 },
            { name: 'Hard', rows: 16, cols: 16, mines: 50, hearts: 5, heartTiles: 7, coinReward: 200 }
        ];
        let currentDifficulty = 0;
        let continueGame = false;
        let savedHearts = 0;

        function initGame() {
            const diff = difficulties[currentDifficulty];
            rows = diff.rows;
            cols = diff.cols;
            mineCount = diff.mines;
            maxHearts = diff.hearts;
            
            // Only reset hearts if:
            // 1. This is the very first game (hearts is 0)
            // 2. Player is continuing from a win (use savedHearts)
            // 3. Otherwise keep current hearts (changing difficulty mid-game)
            if (hearts === 0) {
                // First game ever
                hearts = maxHearts;
            } else if (continueGame) {
                // Continuing from a win
                hearts = savedHearts;
                continueGame = false;
            }
            // else: keep current hearts (player is just changing difficulty)
            
            board = Array(rows).fill().map(() => Array(cols).fill(0));
            revealed = Array(rows).fill().map(() => Array(cols).fill(false));
            flagged = Array(rows).fill().map(() => Array(cols).fill(false));
            mines = [];
            heartTiles = [];
            powerUps = {
                reveal1x1: 3,
                reveal2x2: 2,
                reveal3x3: 1
            };
            activePowerUp = null;
            gameOver = false;
            gameWon = false;
            firstClick = true;
            mouseButtons = { left: false, right: false };
            chordCell = null;
            seconds = 0;
            
            clearInterval(timerInterval);
            updateTimer();
            updateHearts();
            updateFlags();
            updateCoins();
            updatePowerUps();
            updateDifficultyInfo();
            renderBoard();
            hideGameOver();
        }

        function placeMines(excludeRow, excludeCol) {
            let minesPlaced = 0;
            while (minesPlaced < mineCount) {
                const row = Math.floor(Math.random() * rows);
                const col = Math.floor(Math.random() * cols);
                
                // Don't place mine on first click or adjacent cells
                const isExcluded = Math.abs(row - excludeRow) <= 1 && Math.abs(col - excludeCol) <= 1;
                
                if (board[row][col] !== -1 && !isExcluded) {
                    board[row][col] = -1;
                    mines.push([row, col]);
                    minesPlaced++;
                    
                    // Update adjacent cells
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const newRow = row + i;
                            const newCol = col + j;
                            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && board[newRow][newCol] !== -1) {
                                board[newRow][newCol]++;
                            }
                        }
                    }
                }
            }
            
            // Place heart tiles
            const heartTileCount = difficulties[currentDifficulty].heartTiles;
            let heartTilesPlaced = 0;
            while (heartTilesPlaced < heartTileCount) {
                const row = Math.floor(Math.random() * rows);
                const col = Math.floor(Math.random() * cols);
                
                // Don't place heart tile on mines or existing heart tiles
                const isHeartTile = heartTiles.some(([r, c]) => r === row && c === col);
                
                if (board[row][col] !== -1 && !isHeartTile) {
                    heartTiles.push([row, col]);
                    heartTilesPlaced++;
                }
            }
        }

        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            boardElement.style.gridTemplateColumns = `repeat(${cols}, 35px)`;
            
            if (activePowerUp) {
                boardElement.classList.add('powerup-active');
            } else {
                boardElement.classList.remove('powerup-active');
            }
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    const isHeartTile = heartTiles.some(([r, c]) => r === i && c === j);
                    
                    if (revealed[i][j]) {
                        cell.classList.add('revealed');
                        if (board[i][j] === -1) {
                            cell.classList.add('mine');
                            cell.textContent = 'üí£';
                        } else if (isHeartTile) {
                            cell.textContent = 'üíñ';
                            cell.style.fontSize = '20px';
                        } else if (board[i][j] > 0) {
                            cell.textContent = board[i][j];
                            cell.classList.add(`number-${board[i][j]}`);
                        }
                    } else if (flagged[i][j]) {
                        cell.classList.add('flagged');
                        cell.textContent = 'üö©';
                    }
                    
                    cell.addEventListener('click', () => handleCellClick(i, j));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(i, j);
                    });
                    cell.addEventListener('mousedown', (e) => handleMouseDown(e, i, j));
                    cell.addEventListener('mouseup', (e) => handleMouseUp(e, i, j));
                    cell.addEventListener('mouseenter', () => handleCellHover(i, j));
                    cell.addEventListener('mouseleave', () => clearPreview());
                    
                    // Touch events for mobile
                    cell.addEventListener('touchstart', (e) => handleTouchStart(e, i, j));
                    cell.addEventListener('touchend', (e) => handleTouchEnd(e, i, j));
                    cell.addEventListener('touchmove', (e) => handleTouchMove(e));
                    
                    boardElement.appendChild(cell);
                }
            }
        }

        function handleCellClick(row, col) {
            if (gameOver || gameWon || revealed[row][col] || flagged[row][col]) return;
            
            // Handle power-up usage
            if (activePowerUp) {
                usePowerUp(row, col);
                return;
            }
            
            if (firstClick) {
                placeMines(row, col);
                firstClick = false;
                startTimer();
            }
            
            if (board[row][col] === -1) {
                hitMine(row, col);
            } else {
                revealCell(row, col);
                checkWin();
            }
        }

        function handleRightClick(row, col) {
            if (gameOver || gameWon || revealed[row][col]) return;

            initAudioContext();
            flagged[row][col] = !flagged[row][col];
            playFlagSound();
            updateFlags();
            renderBoard();
        }

        function handleMouseDown(e, row, col) {
            if (e.button === 0) mouseButtons.left = true;
            if (e.button === 2) mouseButtons.right = true;
            
            // Check if both buttons are pressed and cell is revealed with a number
            if (mouseButtons.left && mouseButtons.right && revealed[row][col] && board[row][col] > 0) {
                chordCell = { row, col };
                highlightChordCells(row, col, true);
            }
        }

        function handleMouseUp(e, row, col) {
            if (e.button === 0) mouseButtons.left = false;
            if (e.button === 2) mouseButtons.right = false;
            
            // Perform chord click if both buttons were pressed
            if (chordCell && chordCell.row === row && chordCell.col === col) {
                highlightChordCells(row, col, false);
                performChordClick(row, col);
                chordCell = null;
            }
        }

        function highlightChordCells(row, col, highlight) {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const newRow = row + i;
                    const newCol = col + j;
                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                        const cell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
                        if (cell && !revealed[newRow][newCol] && !flagged[newRow][newCol]) {
                            if (highlight) {
                                cell.style.background = '#d5dbdb';
                            } else {
                                cell.style.background = '';
                            }
                        }
                    }
                }
            }
        }

        function performChordClick(row, col) {
            if (gameOver || gameWon || !revealed[row][col] || board[row][col] === 0) return;
            
            // Count flags around the cell
            let flagCount = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const newRow = row + i;
                    const newCol = col + j;
                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && flagged[newRow][newCol]) {
                        flagCount++;
                    }
                }
            }
            
            // If flag count matches or exceeds the number, reveal surrounding cells
            if (flagCount >= board[row][col]) {
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && 
                            !revealed[newRow][newCol] && !flagged[newRow][newCol]) {
                            
                            if (board[newRow][newCol] === -1) {
                                hitMine(newRow, newCol);
                            } else {
                                revealCell(newRow, newCol);
                            }
                        }
                    }
                }
                checkWin();
            }
        }

        function handleTouchStart(e, row, col) {
            e.preventDefault();
            
            touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            longPressTriggered = false;
            
            // Start timer for long press (500ms)
            touchTimer = setTimeout(() => {
                longPressTriggered = true;
                // Long press = flag/unflag (only on unrevealed/locked cells)
                if (!gameOver && !gameWon && !revealed[row][col]) {
                    handleRightClick(row, col);
                    // Vibrate if supported
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }
            }, 500);
        }

        function handleTouchMove(e) {
            // Cancel long press if finger moves too much
            if (touchStartPos && touchTimer) {
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - touchStartPos.x);
                const deltaY = Math.abs(touch.clientY - touchStartPos.y);
                
                if (deltaX > 10 || deltaY > 10) {
                    clearTimeout(touchTimer);
                    touchTimer = null;
                }
            }
        }

        function handleTouchEnd(e, row, col) {
            e.preventDefault();
            
            // Clear the long press timer
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
            
            // If long press was triggered, don't do anything else
            if (longPressTriggered) {
                longPressTriggered = false;
                return;
            }
            
            // Short tap behavior
            if (!gameOver && !gameWon) {
                // If tapping on a revealed number cell, try chord click
                if (revealed[row][col] && board[row][col] > 0) {
                    performChordClick(row, col);
                } else {
                    // Normal click
                    handleCellClick(row, col);
                }
            }
        }

        function activatePowerUp(type) {
            if (gameOver || gameWon) return;
            if (powerUps[type] <= 0) return;
            
            if (activePowerUp === type) {
                // Deactivate if clicking the same power-up
                activePowerUp = null;
            } else {
                activePowerUp = type;
            }
            
            updatePowerUps();
            renderBoard();
        }

        function usePowerUp(centerRow, centerCol) {
            if (!activePowerUp || powerUps[activePowerUp] <= 0) return;

            initAudioContext();
            playPowerUpSound();

            const size = activePowerUp === 'reveal1x1' ? 0 : activePowerUp === 'reveal2x2' ? 1 : 1;
            const range = activePowerUp === 'reveal3x3' ? 1 : activePowerUp === 'reveal2x2' ? 1 : 0;

            // For 1x1, just reveal the clicked cell
            // For 2x2, reveal clicked cell and 1 in each direction (but forms 2x2 from top-left)
            // For 3x3, reveal in a 3x3 area centered on clicked cell

            let cellsToReveal = [];
            
            if (activePowerUp === 'reveal1x1') {
                cellsToReveal.push([centerRow, centerCol]);
            } else if (activePowerUp === 'reveal2x2') {
                // Reveal 2x2 area with clicked cell as top-left
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        const newRow = centerRow + i;
                        const newCol = centerCol + j;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                            cellsToReveal.push([newRow, newCol]);
                        }
                    }
                }
            } else if (activePowerUp === 'reveal3x3') {
                // Reveal 3x3 area centered on clicked cell
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = centerRow + i;
                        const newCol = centerCol + j;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                            cellsToReveal.push([newRow, newCol]);
                        }
                    }
                }
            }
            
            // First click handling
            if (firstClick) {
                placeMines(centerRow, centerCol);
                firstClick = false;
                startTimer();
            }
            
            // Reveal all cells in the area
            let hitMines = false;
            for (let [r, c] of cellsToReveal) {
                if (!revealed[r][c] && !flagged[r][c]) {
                    const isHeartTile = heartTiles.some(([hr, hc]) => hr === r && hc === c);
                    
                    if (board[r][c] === -1) {
                        hitMine(r, c);
                        hitMines = true;
                    } else {
                        revealCell(r, c);
                        
                        // Give heart if it's a heart tile
                        if (isHeartTile) {
                            hearts++;
                            updateHearts();
                            heartTiles = heartTiles.filter(([hr, hc]) => hr !== r || hc !== c);
                            showNotification('üíñ +1 Heart!', '#e74c3c');
                        }
                    }
                }
            }
            
            // Consume power-up
            powerUps[activePowerUp]--;
            activePowerUp = null;
            
            updatePowerUps();
            renderBoard();
            
            if (!hitMines) {
                checkWin();
            }
        }

        function handleCellHover(row, col) {
            if (!activePowerUp || gameOver || gameWon) return;
            
            clearPreview();
            
            let cellsToPreview = [];
            
            if (activePowerUp === 'reveal1x1') {
                cellsToPreview.push([row, col]);
            } else if (activePowerUp === 'reveal2x2') {
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                            cellsToPreview.push([newRow, newCol]);
                        }
                    }
                }
            } else if (activePowerUp === 'reveal3x3') {
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                            cellsToPreview.push([newRow, newCol]);
                        }
                    }
                }
            }
            
            for (let [r, c] of cellsToPreview) {
                const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (cell && !revealed[r][c]) {
                    cell.classList.add('reveal-preview');
                }
            }
        }

        function clearPreview() {
            document.querySelectorAll('.reveal-preview').forEach(cell => {
                cell.classList.remove('reveal-preview');
            });
        }

        function updatePowerUps() {
            document.getElementById('count-1x1').textContent = powerUps.reveal1x1;
            document.getElementById('count-2x2').textContent = powerUps.reveal2x2;
            document.getElementById('count-3x3').textContent = powerUps.reveal3x3;
            
            // Update disabled states
            ['reveal1x1', 'reveal2x2', 'reveal3x3'].forEach(type => {
                const powerupEl = document.getElementById(`powerup-${type.replace('reveal', '')}`);
                if (powerUps[type] <= 0) {
                    powerupEl.classList.add('disabled');
                    powerupEl.classList.remove('active');
                } else {
                    powerupEl.classList.remove('disabled');
                }
                
                if (activePowerUp === type) {
                    powerupEl.classList.add('active');
                } else {
                    powerupEl.classList.remove('active');
                }
            });
        }

        function showNotification(text, color) {
            const notification = document.createElement('div');
            notification.textContent = text;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${color};
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 2000;
                animation: fadeInOut 1.5s ease;
                pointer-events: none;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
                style.remove();
            }, 1500);
        }

        function revealCell(row, col) {
            if (row < 0 || row >= rows || col < 0 || col >= cols || revealed[row][col] || flagged[row][col]) {
                return;
            }

            initAudioContext();
            revealed[row][col] = true;

            // Play appropriate sound based on cell content
            if (board[row][col] === 0) {
                playClickSound();
            } else if (board[row][col] > 0) {
                playNumberSound(board[row][col]);
            }

            // Check if this cell is a heart tile and collect it
            const isHeartTile = heartTiles.some(([r, c]) => r === row && c === col);
            if (isHeartTile) {
                hearts++;
                updateHearts();
                // Remove from heart tiles array
                heartTiles = heartTiles.filter(([r, c]) => r !== row || c !== col);
                // Show notification
                showNotification('üíñ +1 Heart!', '#e74c3c');
            }

            if (board[row][col] === 0) {
                // Reveal adjacent cells
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        revealCell(row + i, col + j);
                    }
                }
            }

            renderBoard();
        }

        function hitMine(row, col) {
            initAudioContext();
            playExplosionSound();
            hearts--;
            revealed[row][col] = true;
            updateHearts();
            renderBoard();

            if (hearts <= 0) {
                endGame(false);
            } else {
                // Flash the cell
                setTimeout(() => {
                    if (!gameOver) {
                        revealed[row][col] = false;
                        renderBoard();
                    }
                }, 500);
            }
        }

        function checkWin() {
            let revealedCount = 0;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (revealed[i][j]) revealedCount++;
                }
            }
            
            if (revealedCount === rows * cols - mineCount) {
                endGame(true);
            }
        }

        function endGame(won) {
            gameOver = true;
            gameWon = won;
            clearInterval(timerInterval);

            if (won) {
                initAudioContext();
                playWinSound();
                // Award coins based on difficulty
                const coinReward = difficulties[currentDifficulty].coinReward;
                coins += coinReward;
                updateCoins();
                savedHearts = hearts; // Save hearts for next game

                // Calculate score and save to leaderboard
                saveScoreToLeaderboard();
            }

            if (!won) {
                // Reveal all mines
                for (let [row, col] of mines) {
                    revealed[row][col] = true;
                }
                renderBoard();
            }

            showGameOver(won);
        }

        function showGameOver(won) {
            const overlay = document.getElementById('gameOverOverlay');
            const message = document.getElementById('gameOverMessage');
            const title = document.getElementById('gameOverTitle');
            const text = document.getElementById('gameOverText');
            const diffSelector = document.getElementById('difficultySelectorWin');
            
            if (won) {
                message.className = 'game-over-message win';
                title.textContent = 'üéâ You Win!';
                const coinReward = difficulties[currentDifficulty].coinReward;
                text.textContent = `Completed in ${seconds} seconds!\nYou earned ü™ô ${coinReward} coins and kept ${hearts} heart${hearts !== 1 ? 's' : ''}!`;
                diffSelector.style.display = 'block';
                document.getElementById('nextDifficulty').value = currentDifficulty;
            } else {
                message.className = 'game-over-message lose';
                title.textContent = 'üíî Game Over';
                text.textContent = 'You ran out of hearts! Better luck next time!';
                diffSelector.style.display = 'none';
            }
            
            overlay.classList.add('show');
        }

        function hideGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('show');
        }

        function updateHearts() {
            const heartsElement = document.getElementById('hearts');
            heartsElement.innerHTML = `<span class="heart-icon">‚ù§Ô∏è</span><span class="heart-count">x${hearts}</span>`;
        }

        function updateFlags() {
            let flagCount = 0;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (flagged[i][j]) flagCount++;
                }
            }
            document.getElementById('flags').textContent = `üö© ${mineCount - flagCount}`;
        }

        function updateCoins() {
            document.getElementById('coins').textContent = `ü™ô ${coins}`;
            document.getElementById('shopCoins').textContent = `ü™ô ${coins}`;
        }

        function updateTimer() {
            document.getElementById('timer').textContent = `‚è±Ô∏è ${seconds}s`;
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                seconds++;
                updateTimer();
            }, 1000);
        }

        function updateDifficultyInfo() {
            const diff = difficulties[currentDifficulty];
            document.getElementById('difficultyInfo').textContent = 
                `${diff.name} (${diff.rows}x${diff.cols}, ${diff.mines} mines, ${diff.hearts} hearts)`;
        }

        function newGame() {
            // Reset to starting hearts for current difficulty
            continueGame = false;
            savedHearts = 0;
            hearts = difficulties[currentDifficulty].hearts;
            initGame();
        }

        function startNextGame() {
            if (gameWon) {
                continueGame = true;
                const selectedDifficulty = document.getElementById('nextDifficulty').value;
                currentDifficulty = parseInt(selectedDifficulty);
            } else {
                continueGame = false;
                savedHearts = 0;
            }
            initGame();
        }

        function openShop() {
            document.getElementById('shopModal').classList.add('show');
            updateCoins();
        }

        function closeShop() {
            document.getElementById('shopModal').classList.remove('show');
        }

        function buyPowerUp(type) {
            const price = shopPrices[type];
            
            if (coins >= price) {
                coins -= price;
                powerUps[type]++;
                updateCoins();
                updatePowerUps();
                showNotification(`Bought ${type.replace('reveal', '')} power-up!`, '#2ecc71');
            } else {
                showNotification('Not enough coins!', '#e74c3c');
            }
        }

        function changeDifficulty() {
            currentDifficulty = (currentDifficulty + 1) % difficulties.length;
            // Don't reset hearts when changing difficulty, only reset the game board
            initGame();
        }

        function resetAll() {
            if (confirm('Are you sure you want to reset everything? This will reset your hearts, coins, and power-ups to default values.')) {
                // Reset everything to initial state
                coins = 0;
                hearts = 0;
                savedHearts = 0;
                continueGame = false;
                currentDifficulty = 0;
                powerUps = {
                    reveal1x1: 3,
                    reveal2x2: 2,
                    reveal3x3: 1
                };
                initGame();
                showNotification('Everything has been reset!', '#e74c3c');
            }
        }

        // Leaderboard functions
        function calculateScore() {
            // Score = (difficulty_multiplier * 1000) / time_in_seconds
            // Easy: multiplier = 1, Medium: multiplier = 2, Hard: multiplier = 3
            const difficultyMultipliers = [1, 2, 3];
            const multiplier = difficultyMultipliers[currentDifficulty];
            const timeInSeconds = seconds || 1; // Prevent division by zero
            const score = Math.round((multiplier * 1000) / timeInSeconds);
            return score;
        }

        function getPlayerName() {
            // Check if player name is already stored
            let playerName = localStorage.getItem('minesweeperPlayerName');

            if (!playerName) {
                // Prompt for player name
                playerName = prompt('Congratulations! Enter your name for the leaderboard:');

                if (!playerName || playerName.trim() === '') {
                    playerName = 'Anonymous';
                } else {
                    playerName = playerName.trim();
                    // Save the name for future games
                    localStorage.setItem('minesweeperPlayerName', playerName);
                }
            }

            return playerName;
        }

        function saveScoreToLeaderboard() {
            const score = calculateScore();
            const playerName = getPlayerName();

            // Get existing scores
            let scores = [];
            try {
                const storedScores = localStorage.getItem('minesweeperScores');
                if (storedScores) {
                    scores = JSON.parse(storedScores);
                }
            } catch (e) {
                console.error('Error loading scores:', e);
                scores = [];
            }

            // Add new score
            const newScore = {
                name: playerName,
                score: score,
                date: new Date().toISOString()
            };
            scores.push(newScore);

            // Sort by score (descending) and keep top 100
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 100);

            // Save back to localStorage
            try {
                localStorage.setItem('minesweeperScores', JSON.stringify(scores));
            } catch (e) {
                console.error('Error saving scores:', e);
            }
        }

        // Initialize game on load
        loadSoundPreference();
        initGame();
    </script>
</body>
</html>