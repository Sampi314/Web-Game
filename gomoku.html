<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Caro Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Mobile optimizations */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        :root {
            --bg-gradient-1: #667eea;
            --bg-gradient-2: #764ba2;
            --accent-primary: #a78bfa;
            --accent-secondary: #c4b5fd;
            --accent-light: #ede9fe;
            --accent-glow: rgba(167, 139, 250, 0.6);
            --plasma-color-1: rgba(167, 139, 250, 0.6);
            --plasma-color-2: rgba(192, 132, 252, 0.5);
            --plasma-color-3: rgba(139, 92, 246, 0.3);
            --plasma-light-1: rgba(167, 139, 250, 0.85);
            --plasma-light-2: rgba(192, 132, 252, 0.75);
            --plasma-light-3: rgba(139, 92, 246, 0.65);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            margin: 0;
            overflow-x: hidden;
            transition: background 0.5s ease;
        }

        .game-container {
            background: rgba(15, 32, 39, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            width: 100%;
            max-width: 700px;
            border: 1px solid var(--accent-primary);
            transition: border-color 0.3s ease;
        }

        h1 {
            text-align: center;
            color: var(--accent-primary);
            margin-bottom: 10px;
            font-size: clamp(1.5em, 5vw, 2.5em);
            text-shadow: 0 0 20px var(--accent-glow);
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }

        .subtitle {
            text-align: center;
            color: var(--accent-secondary);
            margin-bottom: 15px;
            font-size: clamp(0.8em, 2.5vw, 0.9em);
            transition: color 0.3s ease;
        }

        .top-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .settings-btn {
            background: rgba(100, 181, 246, 0.2);
            color: var(--accent-primary);
            border: 2px solid var(--accent-primary);
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .settings-btn:hover {
            background: rgba(100, 181, 246, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--accent-glow);
        }

        .new-game-btn {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .new-game-btn:hover {
            background: linear-gradient(135deg, #2a5298 0%, #3764c7 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(42, 82, 152, 0.5);
        }

        .sound-toggle-btn {
            background: linear-gradient(135deg, #2d5016 0%, #3d6b1f 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .sound-toggle-btn:hover {
            background: linear-gradient(135deg, #3d6b1f 0%, #4d8528 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(61, 107, 31, 0.5);
        }

        .settings-panel {
            background: rgba(15, 32, 39, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid var(--accent-primary);
            animation: slideDown 0.3s ease-out;
            transition: border-color 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .settings-section {
            background: rgba(32, 58, 67, 0.6);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid var(--accent-primary);
            transition: border-color 0.3s ease;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-section h3 {
            color: var(--accent-primary);
            margin-bottom: 12px;
            font-size: 1.1em;
            text-align: center;
            transition: color 0.3s ease;
        }

        .theme-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .theme-option-btn {
            background: rgba(100, 181, 246, 0.2) !important;
            background-image: none !important;
            background-size: auto !important;
            background-position: initial !important;
            color: var(--accent-light);
            border: 2px solid var(--accent-primary);
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: bold;
            transition: all 0.3s;
        }

        .theme-option-btn:hover {
            background: rgba(100, 181, 246, 0.3) !important;
            background-image: none !important;
            transform: translateY(-2px);
        }

        .theme-option-btn.active {
            background: var(--accent-primary) !important;
            background-image: none !important;
            color: #000428;
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .rules-options, .mode-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .rule-btn, .mode-btn {
            background: rgba(32, 58, 67, 0.8);
            color: var(--accent-light);
            border: 2px solid var(--accent-primary);
            padding: 12px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rule-btn:hover, .mode-btn:hover {
            background: rgba(100, 181, 246, 0.2);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .rule-btn.active, .mode-btn.active {
            background: rgba(100, 181, 246, 0.3);
            border-color: var(--accent-primary);
        }

        .rule-icon, .mode-icon {
            font-size: 1.2em;
        }

        .sound-settings {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .volume-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .volume-control label {
            color: var(--accent-light);
            font-weight: 600;
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-slider {
            width: 100%;
            height: 6px;
            border-radius: 5px;
            background: linear-gradient(to right, 
                rgba(100, 181, 246, 0.3) 0%, 
                var(--accent-primary) 50%, 
                var(--accent-primary) 100%);
            outline: none;
            transition: all 0.3s;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 0 10px var(--accent-glow);
            transition: all 0.3s;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px var(--accent-glow);
            transition: all 0.3s;
        }

        .volume-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .bot-config {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }

        .config-row label {
            color: var(--accent-light);
            font-weight: 600;
            font-size: 1em;
            transition: color 0.3s ease;
        }

        .config-row select {
            padding: 8px 15px;
            border: 2px solid var(--accent-primary);
            border-radius: 10px;
            background: rgba(15, 32, 39, 0.9);
            color: var(--accent-light);
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            min-width: 150px;
            transition: all 0.3s ease;
        }

        .config-row select:focus {
            outline: none;
            border-color: var(--accent-secondary);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .game-info {
            background: rgba(32, 58, 67, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid var(--accent-primary);
            text-align: center;
            transition: border-color 0.3s ease;
        }

        .current-player {
            font-size: clamp(1em, 3vw, 1.2em);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: var(--accent-light);
            margin-bottom: 8px;
            transition: color 0.3s ease;
        }

        .player-indicator {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid #333;
            flex-shrink: 0;
        }

        .player-indicator.black {
            background: #000;
        }

        .player-indicator.white {
            background: #fff;
        }

        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 8px 12px;
            font-size: clamp(0.8em, 2.5vw, 1em);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .reset-btn {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
        }

        .reset-btn:hover {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
        }

        .reset-btn:active {
            transform: scale(0.95);
        }

        .variant-btn {
            background: linear-gradient(135deg, #0f2027 0%, #203a43 100%);
            color: white;
        }

        .variant-btn:hover {
            background: linear-gradient(135deg, #203a43 0%, #2c5364 100%);
        }

        .variant-btn:active {
            transform: scale(0.95);
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            overflow-x: auto;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(19, min(25px, 4vw));
            grid-template-rows: repeat(19, min(25px, 4vw));
            gap: 0;
            background: #c9a961;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            position: relative;
            touch-action: none;
            transition: background 0.3s ease;
        }

        /* Board style variants */
        .board.board-classic {
            background: #c9a961;
        }

        .board.board-dark {
            background: #3a2820;
        }

        .board.board-bamboo {
            background: #d4c5a0;
            background-image: 
                repeating-linear-gradient(90deg, #d4c5a0 0px, #c9ba95 3px, #d4c5a0 6px),
                repeating-linear-gradient(0deg, transparent 0px, rgba(160, 140, 100, 0.1) 50%, transparent 100%);
        }

        .board.board-marble {
            background: #f0f0f0;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(200, 200, 200, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(180, 180, 180, 0.2) 0%, transparent 50%);
        }

        .board.board-stone {
            background: #708090;
            background-image: 
                radial-gradient(circle at 30% 40%, rgba(112, 128, 144, 0.8), rgba(47, 79, 79, 0.9));
        }

        .board.board-neon {
            background: #1a1a2e;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(0, 100, 150, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(100, 0, 150, 0.3) 0%, transparent 50%);
            box-shadow: 
                0 10px 30px rgba(0, 255, 255, 0.4), 
                inset 0 0 50px rgba(0, 150, 200, 0.2);
        }

        .board.board-glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            box-shadow: 
                0 10px 40px var(--accent-glow),
                inset 0 0 80px rgba(255, 255, 255, 0.03),
                inset 0 0 30px var(--accent-glow);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .board.board-metal {
            background: linear-gradient(135deg, #c0c0c0 0%, #808080 100%);
            box-shadow: 
                inset 0 2px 10px rgba(255, 255, 255, 0.3),
                inset 0 -2px 10px rgba(0, 0, 0, 0.3),
                0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .board.board-space {
            background: #0a0a15;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 10px 30px rgba(100, 50, 200, 0.4),
                inset 0 0 80px rgba(100, 100, 255, 0.1);
        }
        
        .board.board-space::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 30% 40%, rgba(100, 50, 200, 0.5) 0%, transparent 25%),
                radial-gradient(circle at 70% 60%, rgba(50, 100, 200, 0.4) 0%, transparent 28%),
                radial-gradient(circle at 50% 80%, rgba(150, 100, 255, 0.35) 0%, transparent 30%);
            animation: plasmaFlow 45s ease-in-out infinite;
            pointer-events: none;
        }
        
        .board.board-space::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 80% 20%, rgba(200, 50, 255, 0.4) 0%, transparent 30%),
                radial-gradient(circle at 20% 70%, rgba(50, 150, 255, 0.35) 0%, transparent 32%),
                radial-gradient(circle at 45% 35%, rgba(180, 80, 255, 0.3) 0%, transparent 35%);
            animation: plasmaFlow 60s ease-in-out infinite reverse;
            pointer-events: none;
        }
        
        @keyframes plasmaFlow {
            0%, 100% {
                transform: translate(0, 0) scale(1);
            }
            20% {
                transform: translate(5%, -3%) scale(1.05);
            }
            40% {
                transform: translate(-3%, 6%) scale(0.98);
            }
            60% {
                transform: translate(-6%, -4%) scale(1.03);
            }
            80% {
                transform: translate(4%, 5%) scale(0.97);
            }
        }

        .board.board-paper {
            background: #faf8f5;
            background-image: 
                radial-gradient(circle at 30% 40%, rgba(220, 210, 200, 0.2) 0%, transparent 60%);
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.05),
                0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .board.board-cherry {
            background: #c67c65;
            background-image: 
                repeating-linear-gradient(90deg, #c67c65 0px, #b86b54 3px, #c67c65 6px),
                repeating-linear-gradient(0deg, transparent 0px, rgba(139, 69, 19, 0.1) 50%, transparent 100%);
            box-shadow: 0 10px 30px rgba(139, 69, 19, 0.4);
        }

        .board.board-crystal {
            background: 
                linear-gradient(135deg, rgba(200, 220, 255, 0.15) 0%, rgba(180, 200, 240, 0.1) 100%),
                radial-gradient(circle at 20% 30%, var(--accent-glow) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, var(--accent-glow) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05), transparent);
            backdrop-filter: blur(20px);
            box-shadow: 
                0 10px 50px var(--accent-glow),
                inset 0 0 100px rgba(255, 255, 255, 0.03),
                inset 0 0 50px var(--accent-glow);
            border: 2px solid var(--accent-primary);
            position: relative;
            overflow: hidden;
        }
        
        .board.board-crystal::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                linear-gradient(45deg, transparent 30%, var(--accent-glow) 31%, transparent 32%),
                linear-gradient(-45deg, transparent 30%, var(--accent-glow) 31%, transparent 32%),
                linear-gradient(135deg, transparent 48%, var(--accent-glow) 49%, transparent 50%),
                linear-gradient(-135deg, transparent 48%, var(--accent-glow) 49%, transparent 50%);
            background-size: 100px 100px;
            opacity: 0.05;
            animation: crystalShimmer 20s linear infinite;
        }
        
        @keyframes crystalShimmer {
            0% { transform: translate(0, 0) rotate(0deg); }
            100% { transform: translate(50px, 50px) rotate(360deg); }
        }

        .cell {
            width: min(25px, 4vw);
            height: min(25px, 4vw);
            position: relative;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        /* Draw the grid lines */
        .cell::before,
        .cell::after {
            content: '';
            position: absolute;
            background: #000;
        }

        /* Horizontal line */
        .cell::before {
            height: 1px;
            width: 100%;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        /* Vertical line */
        .cell::after {
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }

        /* Remove lines from edges */
        .cell[data-col="0"]::before {
            left: 50%;
            width: 50%;
        }

        .cell[data-col="18"]::before {
            width: 50%;
        }

        .cell[data-row="0"]::after {
            top: 50%;
            height: 50%;
        }

        .cell[data-row="18"]::after {
            height: 50%;
        }

        /* Grid line colors for different board styles */
        .board-classic .cell::before,
        .board-classic .cell::after {
            background: #8b5a2b;
        }

        .board-dark .cell::before,
        .board-dark .cell::after {
            background: #1a0f08;
        }

        .board-bamboo .cell::before,
        .board-bamboo .cell::after {
            background: #a08c64;
        }

        .board-marble .cell::before,
        .board-marble .cell::after {
            background: #b4b4b4;
        }

        .board-stone .cell::before,
        .board-stone .cell::after {
            background: #2f4f4f;
        }

        .board-neon .cell::before {
            background: linear-gradient(90deg, 
                rgba(0, 255, 255, 0.3) 0%, 
                rgba(0, 255, 255, 0.8) 50%, 
                rgba(0, 255, 255, 0.3) 100%);
            box-shadow: 
                0 0 8px rgba(0, 255, 255, 0.8),
                0 0 15px rgba(0, 255, 255, 0.4);
            height: 2px;
        }

        .board-neon .cell::after {
            background: linear-gradient(180deg, 
                rgba(0, 200, 255, 0.3) 0%, 
                rgba(0, 200, 255, 0.8) 50%, 
                rgba(0, 200, 255, 0.3) 100%);
            box-shadow: 
                0 0 8px rgba(0, 200, 255, 0.8),
                0 0 15px rgba(0, 200, 255, 0.4);
            width: 2px;
        }

        .board-glass .cell::before,
        .board-glass .cell::after {
            background: var(--accent-primary);
            opacity: 0.3;
        }

        .board-metal .cell::before,
        .board-metal .cell::after {
            background: rgba(100, 100, 100, 0.6);
        }

        .board-space .cell::before,
        .board-space .cell::after {
            background: rgba(100, 100, 200, 0.4);
            box-shadow: 0 0 3px rgba(150, 150, 255, 0.3);
        }

        .board-paper .cell::before,
        .board-paper .cell::after {
            background: rgba(200, 190, 180, 0.4);
        }

        .board-cherry .cell::before,
        .board-cherry .cell::after {
            background: rgba(139, 69, 19, 0.4);
        }

        .board-crystal .cell::before {
            background: linear-gradient(90deg, 
                transparent 0%, 
                var(--accent-primary) 50%, 
                transparent 100%);
            opacity: 0.4;
            height: 2px;
            box-shadow: 0 0 5px var(--accent-glow);
        }

        .board-crystal .cell::after {
            background: linear-gradient(180deg, 
                transparent 0%, 
                var(--accent-primary) 50%, 
                transparent 100%);
            opacity: 0.4;
            width: 2px;
            box-shadow: 0 0 5px var(--accent-glow);
        }

        /* Star points (hoshi) - traditional Go board markers */
        .star-point {
            position: relative;
        }

        .star-point .star-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #000;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            pointer-events: none;
        }

        .board-neon .star-point .star-dot {
            background: #00ffff;
            box-shadow: 
                0 0 10px rgba(0, 255, 255, 0.8),
                0 0 20px rgba(0, 255, 255, 0.4);
        }

        .board-neon .cell:not(.has-stone):hover {
            background: rgba(0, 150, 200, 0.15);
        }

        /* Hover shadow effect */
        .cell:not(.has-stone):hover {
            position: relative;
        }

        .cell:not(.has-stone):hover .hover-shadow {
            display: block;
        }

        .hover-shadow {
            width: min(22px, 3.5vw);
            height: min(22px, 3.5vw);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
            display: none;
            opacity: 0.5;
        }

        /* Classic style shadows */
        .hover-shadow.black.shadow-classic {
            background: radial-gradient(circle at 35% 35%, #555, #000);
            border: 1px solid #000;
        }
        .hover-shadow.white.shadow-classic {
            background: radial-gradient(circle at 35% 35%, #fff, #e0e0e0);
            border: 1px solid #999;
        }

        /* Glossy style shadows */
        .hover-shadow.black.shadow-glossy {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: inset -2px -2px 4px rgba(255, 255, 255, 0.3);
            border: 1px solid #000;
        }
        .hover-shadow.white.shadow-glossy {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            box-shadow: inset -2px -2px 4px rgba(255, 255, 255, 0.8);
            border: 1px solid #aaa;
        }

        /* Flat style shadows */
        .hover-shadow.black.shadow-flat {
            background: #1a1a1a;
            border: 2px solid #000;
        }
        .hover-shadow.white.shadow-flat {
            background: #f5f5f5;
            border: 2px solid #ddd;
        }

        /* Neon style shadows */
        .hover-shadow.black.shadow-neon {
            background: #000;
            box-shadow: 0 0 15px #00ffff, inset 0 0 10px #00ffff;
            border: 2px solid #00ffff;
        }
        
        .hover-shadow.black.shadow-neon.custom-colored {
            box-shadow: 0 0 15px var(--custom-tint), inset 0 0 10px var(--custom-tint);
            border: 2px solid var(--custom-tint);
        }
        
        .hover-shadow.white.shadow-neon {
            background: #fff;
            box-shadow: 0 0 15px #ff00ff, inset 0 0 10px #ff00ff;
            border: 2px solid #ff00ff;
        }
        
        .hover-shadow.white.shadow-neon.custom-colored {
            box-shadow: 0 0 15px var(--custom-tint), inset 0 0 10px var(--custom-tint);
            border: 2px solid var(--custom-tint);
        }

        /* Glass style shadows */
        .hover-shadow.black.shadow-glass {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(50, 50, 50, 0.55) 100%);
            backdrop-filter: blur(8px);
            box-shadow: inset -2px -2px 6px rgba(255, 255, 255, 0.15);
            border: 1px solid var(--accent-primary);
        }
        .hover-shadow.white.shadow-glass {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.75) 0%, rgba(230, 230, 230, 0.6) 100%);
            backdrop-filter: blur(8px);
            box-shadow: inset -2px -2px 6px rgba(255, 255, 255, 0.7);
            border: 1px solid var(--accent-primary);
        }

        /* Marble style shadows */
        .hover-shadow.black.shadow-marble {
            background: 
                radial-gradient(circle at 20% 30%, rgba(100, 100, 100, 0.5) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(80, 80, 80, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 35% 35%, #444, #000);
            border: 1px solid #000;
        }
        .hover-shadow.white.shadow-marble {
            background: 
                radial-gradient(circle at 20% 30%, rgba(200, 200, 200, 0.5) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(180, 180, 180, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 35% 35%, #fff, #ddd);
            border: 1px solid #999;
        }

        /* Crystal hover shadows */
        .hover-shadow.black.shadow-crystal {
            background: linear-gradient(45deg, rgba(0, 0, 30, 0.75) 0%, rgba(50, 50, 80, 0.85) 100%);
            box-shadow: inset -3px -3px 8px rgba(255, 255, 255, 0.3), 0 0 20px var(--accent-glow);
            border: none;
            clip-path: polygon(
                50% 5%, 
                70% 18%, 
                88% 28%, 
                95% 50%, 
                85% 72%, 
                68% 90%, 
                50% 95%, 
                32% 90%, 
                15% 72%, 
                5% 50%, 
                12% 28%, 
                30% 18%
            );
        }
        .hover-shadow.white.shadow-crystal {
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.85) 0%, rgba(230, 240, 255, 0.75) 100%);
            box-shadow: inset -3px -3px 8px rgba(255, 255, 255, 0.8), 0 0 20px var(--accent-glow);
            border: none;
            clip-path: polygon(
                50% 5%, 
                68% 15%, 
                85% 30%, 
                95% 50%, 
                82% 75%, 
                62% 88%, 
                50% 95%, 
                38% 88%, 
                18% 75%, 
                5% 50%, 
                15% 30%, 
                32% 15%
            );
        }

        /* Metal hover shadows */
        .hover-shadow.black.shadow-metal {
            background: radial-gradient(circle at 30% 30%, #444, #000);
            box-shadow: inset -2px -2px 5px rgba(100, 100, 100, 0.5);
            border: 1px solid #333;
        }
        .hover-shadow.white.shadow-metal {
            background: radial-gradient(circle at 30% 30%, #fff, #bbb);
            box-shadow: inset -2px -2px 5px rgba(255, 255, 255, 0.8);
            border: 1px solid #aaa;
        }

        /* Gem hover shadows */
        .hover-shadow.black.shadow-gem {
            background: conic-gradient(from 45deg, #000 0deg, #1a0033 60deg, #000 120deg, #330033 180deg, #000 240deg, #1a0033 300deg, #000 360deg);
            box-shadow: 0 0 15px rgba(150, 0, 255, 0.4);
            border: 1px solid rgba(150, 0, 255, 0.6);
        }
        .hover-shadow.white.shadow-gem {
            background: conic-gradient(from 45deg, #fff 0deg, #ffe6ff 60deg, #fff 120deg, #f0e6ff 180deg, #fff 240deg, #ffe6ff 300deg, #fff 360deg);
            box-shadow: 0 0 15px rgba(255, 200, 255, 0.6);
            border: 1px solid rgba(255, 200, 255, 0.6);
        }

        /* Wood hover shadows */
        .hover-shadow.black.shadow-wood {
            background: radial-gradient(circle at 35% 35%, #3a2820, #1a0f08);
            border: 1px solid #1a0f08;
        }
        .hover-shadow.white.shadow-wood {
            background: radial-gradient(circle at 35% 35%, #ffe4b5, #daa520);
            border: 1px solid #daa520;
        }

        /* Plasma hover shadows */
        .hover-shadow.black.shadow-plasma {
            background: radial-gradient(circle at 50% 50%, #000, #1a001a);
            box-shadow: 0 0 20px var(--accent-glow);
            border: none;
        }
        .hover-shadow.white.shadow-plasma {
            background: radial-gradient(circle at 50% 50%, #fff, #ffe6ff);
            box-shadow: 0 0 20px var(--accent-glow);
            border: none;
        }

        /* Ceramic hover shadows */
        .hover-shadow.black.shadow-ceramic {
            background: radial-gradient(circle at 40% 40%, #3a3a3a, #1a1a1a);
            border: 1px solid #2a2a2a;
        }
        .hover-shadow.white.shadow-ceramic {
            background: radial-gradient(circle at 40% 40%, #fff, #f0f0f0);
            border: 1px solid #e0e0e0;
        }

        /* Paper hover shadows - X marker */
        .hover-shadow.black.shadow-paper {
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
        }
        
        .hover-shadow.black.shadow-paper::before,
        .hover-shadow.black.shadow-paper::after {
            content: '';
            position: absolute;
            width: 85%;
            height: 4px;
            background: rgba(231, 76, 60, 0.3);
            border-radius: 2px;
            top: 50%;
            left: 50%;
        }
        
        .hover-shadow.black.shadow-paper::before {
            transform: translate(-50%, -50%) rotate(45deg);
        }
        
        .hover-shadow.black.shadow-paper::after {
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        
        /* Paper hover shadows - O marker */
        .hover-shadow.white.shadow-paper {
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
        }
        
        .hover-shadow.white.shadow-paper::before {
            content: '';
            position: absolute;
            width: 65%;
            height: 65%;
            border: 4px solid rgba(52, 152, 219, 0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Custom color overlay for stones (except neon and paper which handle color differently) */
        .stone.custom-colored:not(.stone-neon):not(.stone-paper)::before,
        .hover-shadow.custom-colored:not(.shadow-neon):not(.shadow-paper)::before,
        .preview-stone.custom-colored:not([class*="-neon"]):not([class*="-paper"])::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: var(--custom-tint);
            mix-blend-mode: multiply;
            pointer-events: none;
            opacity: 0.7;
        }

        .stone {
            width: min(22px, 3.5vw);
            height: min(22px, 3.5vw);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            animation: placeStone 0.3s ease-out forwards;
        }

        /* Classic style (default) */
        .stone.black.stone-classic {
            background: radial-gradient(circle at 35% 35%, #555, #000);
            border: 1px solid #000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }
        .stone.white.stone-classic {
            background: radial-gradient(circle at 35% 35%, #fff, #e0e0e0);
            border: 1px solid #999;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Glossy style */
        .stone.black.stone-glossy {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: inset -2px -2px 4px rgba(255, 255, 255, 0.3), 0 2px 8px rgba(0, 0, 0, 0.8);
            border: 1px solid #000;
        }
        .stone.white.stone-glossy {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            box-shadow: inset -2px -2px 4px rgba(255, 255, 255, 0.8), 0 2px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid #aaa;
        }

        /* Flat style */
        .stone.black.stone-flat {
            background: #1a1a1a;
            border: 2px solid #000;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        .stone.white.stone-flat {
            background: #f5f5f5;
            border: 2px solid #ddd;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Neon style */
        .stone.black.stone-neon {
            background: #000;
            box-shadow: 0 0 15px #00ffff, inset 0 0 10px #00ffff, 0 0 25px rgba(0, 255, 255, 0.5);
            border: 2px solid #00ffff;
        }
        
        .stone.black.stone-neon.custom-colored {
            box-shadow: 0 0 15px var(--custom-tint), inset 0 0 10px var(--custom-tint), 0 0 25px var(--custom-tint);
            border: 2px solid var(--custom-tint);
        }
        
        .stone.white.stone-neon {
            background: #fff;
            box-shadow: 0 0 15px #ff00ff, inset 0 0 10px #ff00ff, 0 0 25px rgba(255, 0, 255, 0.5);
            border: 2px solid #ff00ff;
        }
        
        .stone.white.stone-neon.custom-colored {
            box-shadow: 0 0 15px var(--custom-tint), inset 0 0 10px var(--custom-tint), 0 0 25px var(--custom-tint);
            border: 2px solid var(--custom-tint);
        }

        /* Glass style */
        .stone.black.stone-glass {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.75) 0%, rgba(50, 50, 50, 0.6) 100%);
            backdrop-filter: blur(8px);
            box-shadow: 
                inset -2px -2px 6px rgba(255, 255, 255, 0.15),
                0 4px 8px rgba(0, 0, 0, 0.5),
                0 0 15px var(--accent-glow);
            border: 1px solid var(--accent-primary);
        }
        .stone.white.stone-glass {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(230, 230, 230, 0.65) 100%);
            backdrop-filter: blur(8px);
            box-shadow: 
                inset -2px -2px 6px rgba(255, 255, 255, 0.7),
                0 4px 8px rgba(0, 0, 0, 0.3),
                0 0 15px var(--accent-glow);
            border: 1px solid var(--accent-primary);
        }

        /* Marble style */
        .stone.black.stone-marble {
            background: 
                radial-gradient(circle at 20% 30%, rgba(100, 100, 100, 0.5) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(80, 80, 80, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 35% 35%, #444, #000);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            border: 1px solid #000;
        }
        .stone.white.stone-marble {
            background: 
                radial-gradient(circle at 20% 30%, rgba(200, 200, 200, 0.5) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(180, 180, 180, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 35% 35%, #fff, #ddd);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            border: 1px solid #999;
        }

        /* Crystal style */
        .stone.black.stone-crystal {
            background: 
                linear-gradient(115deg, transparent 25%, var(--plasma-color-1) 26%, transparent 27%),
                linear-gradient(245deg, transparent 35%, var(--plasma-color-2) 36%, transparent 37%),
                linear-gradient(155deg, transparent 45%, var(--plasma-color-3) 46%, transparent 47%),
                linear-gradient(205deg, transparent 55%, var(--plasma-color-1) 56%, transparent 57%),
                linear-gradient(75deg, transparent 60%, var(--plasma-color-2) 61%, transparent 62%),
                radial-gradient(ellipse at 35% 35%, rgba(80, 80, 120, 0.8), rgba(10, 10, 40, 1));
            backdrop-filter: blur(2px);
            box-shadow: 
                inset -3px -3px 6px rgba(255, 255, 255, 0.3),
                inset 3px 3px 6px rgba(0, 0, 0, 0.5),
                0 0 15px var(--accent-glow);
            border: none;
            border-radius: 0;
            clip-path: polygon(
                50% 0%, 75% 15%, 93% 28%, 100% 50%, 88% 75%, 68% 92%, 50% 100%, 32% 92%, 12% 75%, 0% 50%, 7% 28%, 25% 15%
            );
        }
        .stone.white.stone-crystal {
            background: 
                linear-gradient(115deg, transparent 25%, var(--plasma-light-1) 26%, transparent 27%),
                linear-gradient(245deg, transparent 35%, var(--plasma-light-2) 36%, transparent 37%),
                linear-gradient(155deg, transparent 45%, var(--plasma-light-3) 46%, transparent 47%),
                linear-gradient(205deg, transparent 55%, var(--plasma-light-1) 56%, transparent 57%),
                linear-gradient(75deg, transparent 60%, var(--plasma-light-2) 61%, transparent 62%),
                radial-gradient(ellipse at 35% 35%, rgba(255, 255, 255, 1), rgba(220, 230, 250, 0.95));
            backdrop-filter: blur(2px);
            box-shadow: 
                inset -3px -3px 6px rgba(255, 255, 255, 0.9),
                inset 3px 3px 6px rgba(180, 180, 210, 0.4),
                0 0 15px var(--accent-glow);
            border: none;
            border-radius: 0;
            clip-path: polygon(
                50% 0%, 72% 18%, 90% 32%, 100% 50%, 85% 72%, 65% 88%, 50% 100%, 35% 88%, 15% 72%, 0% 50%, 10% 32%, 28% 18%
            );
        }

        /* Metal style */
        .stone.black.stone-metal {
            background: 
                linear-gradient(135deg, #1a1a1a 0%, #000 50%, #1a1a1a 100%),
                radial-gradient(circle at 30% 30%, #444, #000);
            box-shadow: inset -2px -2px 5px rgba(100, 100, 100, 0.5), inset 2px 2px 5px rgba(0, 0, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
        }
        .stone.white.stone-metal {
            background: 
                linear-gradient(135deg, #e8e8e8 0%, #c0c0c0 50%, #e8e8e8 100%),
                radial-gradient(circle at 30% 30%, #fff, #bbb);
            box-shadow: inset -2px -2px 5px rgba(255, 255, 255, 0.8), inset 2px 2px 5px rgba(100, 100, 100, 0.3), 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid #aaa;
        }

        /* Gem style */
        .stone.black.stone-gem {
            background: 
                conic-gradient(from 45deg, #000 0deg, #1a0033 60deg, #000 120deg, #330033 180deg, #000 240deg, #1a0033 300deg, #000 360deg);
            box-shadow: inset -2px -2px 6px rgba(150, 0, 150, 0.5), inset 2px 2px 6px rgba(0, 0, 0, 0.8), 0 0 15px rgba(150, 0, 255, 0.4);
            border: 1px solid rgba(150, 0, 255, 0.6);
        }
        .stone.white.stone-gem {
            background: 
                conic-gradient(from 45deg, #fff 0deg, #ffe6ff 60deg, #fff 120deg, #f0e6ff 180deg, #fff 240deg, #ffe6ff 300deg, #fff 360deg);
            box-shadow: inset -2px -2px 6px rgba(255, 255, 255, 0.8), inset 2px 2px 6px rgba(200, 150, 255, 0.3), 0 0 15px rgba(255, 200, 255, 0.6);
            border: 1px solid rgba(255, 200, 255, 0.6);
        }

        /* Wood style */
        .stone.black.stone-wood {
            background: 
                linear-gradient(90deg, transparent 0%, rgba(60, 40, 20, 0.3) 20%, transparent 40%, rgba(50, 30, 15, 0.4) 60%, transparent 80%),
                repeating-linear-gradient(0deg, #2a1810 0px, #3a2015 1px, #2a1810 2px, #1a0f08 3px, #2a1810 6px),
                radial-gradient(ellipse 80% 100% at 50% 100%, #3a2820, #1a0f08);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            border: 1px solid #1a0f08;
        }
        .stone.white.stone-wood {
            background: 
                linear-gradient(90deg, transparent 0%, rgba(220, 180, 140, 0.4) 20%, transparent 40%, rgba(200, 160, 120, 0.5) 60%, transparent 80%),
                repeating-linear-gradient(0deg, #f5deb3 0px, #e8d4a8 1px, #f5deb3 2px, #daa520 3px, #f5deb3 6px),
                radial-gradient(ellipse 80% 100% at 50% 100%, #ffe4b5, #daa520);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid #c89030;
        }

        /* Plasma style */
        .stone.black.stone-plasma {
            position: relative;
            background: radial-gradient(circle at 50% 50%, #1a1a1a, #000);
            box-shadow: 0 0 20px var(--accent-glow);
            border: none;
            overflow: hidden;
            border-radius: 50%;
        }
        
        .stone.black.stone-plasma::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 35% 35%, var(--plasma-color-1) 0%, transparent 30%),
                radial-gradient(circle at 65% 65%, var(--plasma-color-2) 0%, transparent 32%),
                radial-gradient(circle at 50% 50%, var(--plasma-color-3) 0%, transparent 40%);
            animation: plasmaFluid 30s ease-in-out infinite;
            opacity: 0.8;
        }
        
        .stone.black.stone-plasma::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 65% 35%, var(--plasma-color-2) 0%, transparent 35%),
                radial-gradient(circle at 35% 65%, var(--plasma-color-1) 0%, transparent 33%);
            animation: plasmaFluid 40s ease-in-out infinite reverse;
            opacity: 0.7;
        }
        
        .stone.white.stone-plasma {
            position: relative;
            background: radial-gradient(circle at 50% 50%, #ffffff, #f5f5f5);
            box-shadow: 0 0 20px var(--accent-glow);
            border: none;
            overflow: hidden;
            border-radius: 50%;
        }
        
        .stone.white.stone-plasma::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 35% 35%, rgba(255, 140, 60, 0.5) 0%, transparent 30%),
                radial-gradient(circle at 65% 65%, rgba(255, 180, 100, 0.4) 0%, transparent 32%),
                radial-gradient(circle at 50% 50%, rgba(255, 200, 150, 0.3) 0%, transparent 40%);
            animation: plasmaFluid 30s ease-in-out infinite;
            opacity: 0.7;
        }
        
        .stone.white.stone-plasma::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 65% 35%, rgba(255, 160, 80, 0.45) 0%, transparent 35%),
                radial-gradient(circle at 35% 65%, rgba(255, 120, 50, 0.4) 0%, transparent 33%);
            animation: plasmaFluid 40s ease-in-out infinite reverse;
            opacity: 0.6;
        }

        @keyframes plasmaFluid {
            0%, 100% {
                transform: translate(0, 0) scale(1);
            }
            20% {
                transform: translate(8%, -5%) scale(1.03);
            }
            40% {
                transform: translate(-5%, 8%) scale(0.98);
            }
            60% {
                transform: translate(-7%, -6%) scale(1.02);
            }
            80% {
                transform: translate(6%, 7%) scale(0.99);
            }
        }

        @keyframes plasmaRotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Ceramic style */
        .stone.black.stone-ceramic {
            background: 
                radial-gradient(circle at 40% 40%, #3a3a3a, #1a1a1a);
            box-shadow: inset -1px -1px 3px rgba(100, 100, 100, 0.3), 0 2px 4px rgba(0, 0, 0, 0.4);
            border: 1px solid #2a2a2a;
        }
        .stone.white.stone-ceramic {
            background: 
                radial-gradient(circle at 40% 40%, #fff, #f0f0f0);
            box-shadow: inset -1px -1px 3px rgba(255, 255, 255, 0.6), 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid #e0e0e0;
        }

        /* Paper style - Hand-drawn X marker */
        .stone.black.stone-paper {
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
        }
        
        .stone.black.stone-paper::before,
        .stone.black.stone-paper::after {
            content: '';
            position: absolute;
            width: 85%;
            height: 4px;
            background: #e74c3c;
            border-radius: 2px;
            top: 50%;
            left: 50%;
        }
        
        .stone.black.stone-paper::before {
            transform: translate(-50%, -50%) rotate(45deg);
        }
        
        .stone.black.stone-paper::after {
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        
        /* Paper style - Hand-drawn O marker */
        .stone.white.stone-paper {
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
        }
        
        .stone.white.stone-paper::before {
            content: '';
            position: absolute;
            width: 65%;
            height: 65%;
            border: 4px solid #3498db;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Threat alert styling */
        .stone.threat {
            position: relative;
        }

        .stone.threat::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 2px solid var(--accent-primary);
            border-radius: 50%;
            animation: threatPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 15px var(--accent-glow);
        }

        @keyframes threatPulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        @keyframes placeStone {
            0% {
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .message {
            text-align: center;
            font-size: clamp(1em, 3vw, 1.3em);
            font-weight: bold;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent-light);
            margin-top: 10px;
            transition: color 0.3s ease;
        }

        .win-message {
            color: var(--accent-primary);
            animation: pulse 1s infinite;
            text-shadow: 0 0 20px var(--accent-glow);
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        .rules {
            background: rgba(32, 58, 67, 0.8);
            padding: 12px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: clamp(0.75em, 2.2vw, 0.9em);
            color: #b3e5fc;
            border: 1px solid var(--accent-primary);
            transition: border-color 0.3s ease;
        }

        .rules h3 {
            color: var(--accent-primary);
            margin-bottom: 8px;
            font-size: clamp(0.9em, 2.5vw, 1em);
            transition: color 0.3s ease;
        }

        .rules ul {
            margin-left: 20px;
        }

        .rules li {
            margin: 5px 0;
        }

        .rules p {
            margin-top: 8px;
        }

        .variant-info {
            text-align: center;
            color: var(--accent-primary);
            font-weight: bold;
            margin-top: 10px;
            font-size: clamp(0.75em, 2.2vw, 0.9em);
            transition: color 0.3s ease;
        }

        /* Theme Presets */
        /* Bead Set Selector */
        .bead-sets {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
        }

        .bead-set-btn {
            background: rgba(32, 58, 67, 0.8);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .bead-set-btn:hover {
            background: rgba(100, 181, 246, 0.2);
            transform: translateY(-2px);
        }

        .bead-set-btn.active {
            background: rgba(100, 181, 246, 0.3);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .bead-set-btn span {
            color: var(--accent-light);
            font-size: 0.85em;
            font-weight: 600;
        }

        .bead-preview {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .preview-stone {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        /* Classic stones */
        .black-classic { background: radial-gradient(circle at 35% 35%, #555, #000); }
        .white-classic { background: radial-gradient(circle at 35% 35%, #fff, #e0e0e0); }

        /* Glossy stones */
        .black-glossy {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: inset -2px -2px 4px rgba(255, 255, 255, 0.3), 0 2px 6px rgba(0, 0, 0, 0.8);
        }
        .white-glossy {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            box-shadow: inset -2px -2px 4px rgba(255, 255, 255, 0.8), 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        /* Flat stones */
        .black-flat { background: #1a1a1a; border: 2px solid #000; }
        .white-flat { background: #f5f5f5; border: 2px solid #ddd; }

        /* Neon stones */
        .black-neon {
            background: #000;
            box-shadow: 0 0 10px #00ffff, inset 0 0 10px #00ffff;
            border: 2px solid #00ffff;
        }
        
        .black-neon.custom-colored {
            box-shadow: 0 0 10px var(--custom-tint), inset 0 0 10px var(--custom-tint);
            border: 2px solid var(--custom-tint);
        }
        
        .white-neon {
            background: #fff;
            box-shadow: 0 0 10px #ff00ff, inset 0 0 10px #ff00ff;
            border: 2px solid #ff00ff;
        }
        
        .white-neon.custom-colored {
            box-shadow: 0 0 10px var(--custom-tint), inset 0 0 10px var(--custom-tint);
            border: 2px solid var(--custom-tint);
        }

        /* Glass stones */
        .black-glass {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.75) 0%, rgba(50, 50, 50, 0.6) 100%);
            backdrop-filter: blur(8px);
            box-shadow: 
                inset -2px -2px 6px rgba(255, 255, 255, 0.15),
                0 4px 8px rgba(0, 0, 0, 0.5),
                0 0 15px var(--accent-glow);
            border: 1px solid var(--accent-primary);
        }
        .white-glass {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(230, 230, 230, 0.65) 100%);
            backdrop-filter: blur(8px);
            box-shadow: 
                inset -2px -2px 6px rgba(255, 255, 255, 0.7),
                0 4px 8px rgba(0, 0, 0, 0.3),
                0 0 15px var(--accent-glow);
            border: 1px solid var(--accent-primary);
        }

        /* Marble stones */
        .black-marble {
            background: 
                radial-gradient(circle at 20% 30%, rgba(100, 100, 100, 0.5) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(80, 80, 80, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 35% 35%, #444, #000);
        }
        .white-marble {
            background: 
                radial-gradient(circle at 20% 30%, rgba(200, 200, 200, 0.5) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(180, 180, 180, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 35% 35%, #fff, #ddd);
        }

        /* Crystal stones */
        .black-crystal {
            background: 
                linear-gradient(115deg, transparent 25%, var(--plasma-color-1) 26%, transparent 27%),
                linear-gradient(245deg, transparent 35%, var(--plasma-color-2) 36%, transparent 37%),
                linear-gradient(155deg, transparent 45%, var(--plasma-color-3) 46%, transparent 47%),
                linear-gradient(205deg, transparent 55%, var(--plasma-color-1) 56%, transparent 57%),
                radial-gradient(ellipse at 30% 30%, rgba(120, 120, 160, 0.4), rgba(0, 0, 40, 0.9));
            box-shadow: 
                inset -3px -3px 6px rgba(255, 255, 255, 0.2),
                inset 3px 3px 6px rgba(0, 0, 0, 0.6),
                0 0 15px var(--accent-glow);
            border: none;
            clip-path: polygon(
                50% 2%, 73% 14%, 90% 28%, 98% 50%, 87% 75%, 67% 92%, 50% 98%, 33% 92%, 13% 75%, 2% 50%, 10% 28%, 27% 14%
            );
        }
        .white-crystal {
            background: 
                linear-gradient(115deg, transparent 25%, var(--plasma-light-1) 26%, transparent 27%),
                linear-gradient(245deg, transparent 35%, var(--plasma-light-2) 36%, transparent 37%),
                linear-gradient(155deg, transparent 45%, var(--plasma-light-3) 46%, transparent 47%),
                linear-gradient(205deg, transparent 55%, var(--plasma-light-1) 56%, transparent 57%),
                radial-gradient(ellipse at 30% 30%, rgba(255, 255, 255, 0.95), rgba(220, 230, 255, 0.85));
            box-shadow: 
                inset -3px -3px 6px rgba(255, 255, 255, 0.9),
                inset 3px 3px 6px rgba(200, 200, 230, 0.4),
                0 0 15px var(--accent-glow);
            border: none;
            clip-path: polygon(
                50% 2%, 70% 16%, 88% 30%, 98% 50%, 84% 72%, 64% 88%, 50% 98%, 36% 88%, 16% 72%, 2% 50%, 12% 30%, 30% 16%
            );
        }

        /* Metal stones */
        .black-metal {
            background: 
                linear-gradient(135deg, #1a1a1a 0%, #000 50%, #1a1a1a 100%),
                radial-gradient(circle at 30% 30%, #444, #000);
            box-shadow: inset -2px -2px 5px rgba(100, 100, 100, 0.5), inset 2px 2px 5px rgba(0, 0, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
        }
        .white-metal {
            background: 
                linear-gradient(135deg, #e8e8e8 0%, #c0c0c0 50%, #e8e8e8 100%),
                radial-gradient(circle at 30% 30%, #fff, #bbb);
            box-shadow: inset -2px -2px 5px rgba(255, 255, 255, 0.8), inset 2px 2px 5px rgba(100, 100, 100, 0.3), 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid #aaa;
        }

        /* Gem stones */
        .black-gem {
            background: 
                conic-gradient(from 45deg, #000 0deg, #1a0033 60deg, #000 120deg, #330033 180deg, #000 240deg, #1a0033 300deg, #000 360deg);
            box-shadow: inset -2px -2px 6px rgba(150, 0, 150, 0.5), inset 2px 2px 6px rgba(0, 0, 0, 0.8), 0 0 15px rgba(150, 0, 255, 0.4);
            border: 1px solid rgba(150, 0, 255, 0.6);
        }
        .white-gem {
            background: 
                conic-gradient(from 45deg, #fff 0deg, #ffe6ff 60deg, #fff 120deg, #f0e6ff 180deg, #fff 240deg, #ffe6ff 300deg, #fff 360deg);
            box-shadow: inset -2px -2px 6px rgba(255, 255, 255, 0.8), inset 2px 2px 6px rgba(200, 150, 255, 0.3), 0 0 15px rgba(255, 200, 255, 0.6);
            border: 1px solid rgba(255, 200, 255, 0.6);
        }

        /* Wood stones */
        .black-wood {
            background: 
                linear-gradient(90deg, transparent 0%, rgba(60, 40, 20, 0.3) 20%, transparent 40%, rgba(50, 30, 15, 0.4) 60%, transparent 80%),
                repeating-linear-gradient(0deg, #2a1810 0px, #3a2015 1px, #2a1810 2px, #1a0f08 3px, #2a1810 6px),
                radial-gradient(ellipse 80% 100% at 50% 100%, #3a2820, #1a0f08);
            border: 1px solid #1a0f08;
        }
        .white-wood {
            background: 
                linear-gradient(90deg, transparent 0%, rgba(220, 180, 140, 0.4) 20%, transparent 40%, rgba(200, 160, 120, 0.5) 60%, transparent 80%),
                repeating-linear-gradient(0deg, #f5deb3 0px, #e8d4a8 1px, #f5deb3 2px, #daa520 3px, #f5deb3 6px),
                radial-gradient(ellipse 80% 100% at 50% 100%, #ffe4b5, #daa520);
            border: 1px solid #c89030;
        }

        /* Plasma stones */
        .black-plasma {
            background: radial-gradient(circle at 50% 50%, #000, #1a001a);
            box-shadow: 0 0 20px var(--accent-glow);
            border: none;
            position: relative;
            overflow: hidden;
            border-radius: 50%;
        }
        .black-plasma::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 30% 30%, var(--plasma-color-1), transparent 50%),
                radial-gradient(circle at 70% 70%, var(--plasma-color-2), transparent 50%);
            animation: plasmaRotate 5s linear infinite;
            opacity: 0.7;
        }
        
        .white-plasma {
            background: radial-gradient(circle at 50% 50%, #fff, #f0f0f0);
            box-shadow: 0 0 20px var(--accent-glow);
            border: none;
            position: relative;
            overflow: hidden;
            border-radius: 50%;
        }
        .white-plasma::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 30% 30%, var(--plasma-light-1), transparent 50%),
                radial-gradient(circle at 70% 70%, var(--plasma-light-2), transparent 50%);
            animation: plasmaRotate 5s linear infinite;
            opacity: 0.6;
        }

        /* Marble stones */
        .black-marble {
            background: 
                radial-gradient(circle at 20% 30%, rgba(100, 100, 100, 0.5) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(80, 80, 80, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 35% 35%, #444, #000);
        }
        .white-marble {
            background: 
                radial-gradient(circle at 20% 30%, rgba(200, 200, 200, 0.5) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(180, 180, 180, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 35% 35%, #fff, #ddd);
        }

        /* Metal stones */
        .black-metal {
            background: 
                linear-gradient(135deg, #1a1a1a 0%, #000 50%, #1a1a1a 100%),
                radial-gradient(circle at 30% 30%, #444, #000);
            box-shadow: inset -2px -2px 5px rgba(100, 100, 100, 0.5), inset 2px 2px 5px rgba(0, 0, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
        }
        .white-metal {
            background: 
                linear-gradient(135deg, #e8e8e8 0%, #c0c0c0 50%, #e8e8e8 100%),
                radial-gradient(circle at 30% 30%, #fff, #bbb);
            box-shadow: inset -2px -2px 5px rgba(255, 255, 255, 0.8), inset 2px 2px 5px rgba(100, 100, 100, 0.3), 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid #aaa;
        }

        /* Gem stones */
        .black-gem {
            background: 
                conic-gradient(from 45deg, #000 0deg, #1a0033 60deg, #000 120deg, #330033 180deg, #000 240deg, #1a0033 300deg, #000 360deg);
            box-shadow: inset -2px -2px 6px rgba(150, 0, 150, 0.5), inset 2px 2px 6px rgba(0, 0, 0, 0.8), 0 0 15px rgba(150, 0, 255, 0.4);
            border: 1px solid rgba(150, 0, 255, 0.6);
        }
        .white-gem {
            background: 
                conic-gradient(from 45deg, #fff 0deg, #ffe6ff 60deg, #fff 120deg, #f0e6ff 180deg, #fff 240deg, #ffe6ff 300deg, #fff 360deg);
            box-shadow: inset -2px -2px 6px rgba(255, 255, 255, 0.8), inset 2px 2px 6px rgba(200, 150, 255, 0.3), 0 0 15px rgba(255, 200, 255, 0.6);
            border: 1px solid rgba(255, 200, 255, 0.6);
        }

        /* Wood stones */
        .black-wood {
            background: 
                repeating-linear-gradient(90deg, 
                    #1a0f08 0px, #2a1810 1px, #1a0f08 2px, #1a0f08 3px,
                    #2a1810 4px, #1a0f08 5px, #1a0f08 8px, #2a1810 10px,
                    #1a0f08 11px, #1a0f08 15px),
                repeating-linear-gradient(0deg,
                    transparent 0px, transparent 3px,
                    rgba(42, 24, 16, 0.3) 3px, rgba(42, 24, 16, 0.3) 4px,
                    transparent 4px, transparent 8px),
                radial-gradient(ellipse at 30% 40%, #3a2820 0%, #1a0f08 70%);
            box-shadow: 
                inset 0 0 5px rgba(0, 0, 0, 0.5),
                0 2px 4px rgba(0, 0, 0, 0.5);
            border: 1px solid #0d0604;
        }
        .white-wood {
            background: 
                repeating-linear-gradient(90deg, 
                    #daa520 0px, #f5deb3 1px, #daa520 2px, #daa520 3px,
                    #f5deb3 4px, #daa520 5px, #daa520 8px, #f5deb3 10px,
                    #daa520 11px, #daa520 15px),
                repeating-linear-gradient(0deg,
                    transparent 0px, transparent 3px,
                    rgba(245, 222, 179, 0.4) 3px, rgba(245, 222, 179, 0.4) 4px,
                    transparent 4px, transparent 8px),
                radial-gradient(ellipse at 30% 40%, #ffe4b5 0%, #daa520 70%);
            box-shadow: 
                inset 0 0 5px rgba(139, 69, 19, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid #b8860b;
        }

        /* Ceramic stones */
        .black-ceramic {
            background: 
                radial-gradient(circle at 40% 40%, #3a3a3a, #1a1a1a);
            box-shadow: inset -1px -1px 3px rgba(100, 100, 100, 0.3), 0 2px 4px rgba(0, 0, 0, 0.4);
            border: 1px solid #2a2a2a;
        }
        .white-ceramic {
            background: 
                radial-gradient(circle at 40% 40%, #fff, #f0f0f0);
            box-shadow: inset -1px -1px 3px rgba(255, 255, 255, 0.6), 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid #e0e0e0;
        }

        /* Paper bead previews - X marker */
        .black-paper {
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
        }
        
        .black-paper::before,
        .black-paper::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 2px;
            background: #e74c3c;
            border-radius: 1px;
            top: 50%;
            left: 50%;
        }
        
        .black-paper::before {
            transform: translate(-50%, -50%) rotate(45deg);
        }
        
        .black-paper::after {
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        
        /* Paper bead previews - O marker */
        .white-paper {
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
        }
        
        .white-paper::before {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            border: 2px solid #3498db;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Color Customizer */
        .color-customizer {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Board Style Selector */
        .board-styles {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
        }

        .board-style-btn {
            background: rgba(32, 58, 67, 0.8) !important;
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 0;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            overflow: hidden;
            position: relative;
        }

        .board-style-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px var(--accent-glow);
        }
        
        .board-style-btn:hover .board-label {
            background: rgba(100, 181, 246, 0.3);
        }

        .board-style-btn.active {
            box-shadow: 0 0 20px var(--accent-glow);
            border-color: var(--accent-secondary);
        }
        
        .board-style-btn.active .board-label {
            background: rgba(100, 181, 246, 0.4);
        }
        
        .board-style-btn .board-preview-wrapper {
            width: 100%;
            height: 80px;
            position: relative;
        }
        
        .board-style-btn .board-label {
            padding: 10px 12px;
            width: 100%;
            background: rgba(15, 32, 39, 0.95);
        }

        .board-style-btn span {
            color: var(--accent-light);
            font-size: 0.85em;
            font-weight: 600;
            text-align: center;
        }

        .board-preview {
            width: 100%;
            height: 100%;
            border-radius: 0;
            border: none;
            position: relative;
            overflow: hidden;
        }

        /* Board preview styles */
        .board-preview-classic {
            background: #c9a961;
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(139, 90, 43, 0.3) 19px, rgba(139, 90, 43, 0.3) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(139, 90, 43, 0.3) 19px, rgba(139, 90, 43, 0.3) 20px);
        }

        .board-preview-dark {
            background: #3a2820;
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(26, 15, 8, 0.5) 19px, rgba(26, 15, 8, 0.5) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(26, 15, 8, 0.5) 19px, rgba(26, 15, 8, 0.5) 20px);
        }

        .board-preview-bamboo {
            background: #d4c5a0;
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(160, 140, 100, 0.4) 19px, rgba(160, 140, 100, 0.4) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(160, 140, 100, 0.4) 19px, rgba(160, 140, 100, 0.4) 20px);
        }

        .board-preview-marble {
            background: #f0f0f0;
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(180, 180, 180, 0.4) 19px, rgba(180, 180, 180, 0.4) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(180, 180, 180, 0.4) 19px, rgba(180, 180, 180, 0.4) 20px);
        }

        .board-preview-stone {
            background: #708090;
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(47, 79, 79, 0.5) 19px, rgba(47, 79, 79, 0.5) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(47, 79, 79, 0.5) 19px, rgba(47, 79, 79, 0.5) 20px);
        }

        .board-preview-neon {
            background: #1a1a2e;
            background-image: 
                radial-gradient(circle at 30% 40%, rgba(0, 100, 150, 0.3) 0%, transparent 50%),
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(0, 255, 255, 0.7) 19px, rgba(0, 255, 255, 0.7) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(0, 200, 255, 0.7) 19px, rgba(0, 200, 255, 0.7) 20px);
            box-shadow: 
                inset 0 0 15px rgba(0, 150, 200, 0.3),
                0 0 10px rgba(0, 255, 255, 0.3);
        }

        .board-preview-glass {
            background: rgba(200, 220, 240, 0.3);
            backdrop-filter: blur(5px);
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(150, 180, 200, 0.4) 19px, rgba(150, 180, 200, 0.4) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(150, 180, 200, 0.4) 19px, rgba(150, 180, 200, 0.4) 20px);
            box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .board-preview-metal {
            background: linear-gradient(135deg, #c0c0c0, #808080);
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(100, 100, 100, 0.5) 19px, rgba(100, 100, 100, 0.5) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(100, 100, 100, 0.5) 19px, rgba(100, 100, 100, 0.5) 20px);
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .board-preview-space {
            background: #0a0a15;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(100, 50, 200, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(50, 100, 200, 0.2) 0%, transparent 50%),
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(100, 100, 200, 0.3) 19px, rgba(100, 100, 200, 0.3) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(100, 100, 200, 0.3) 19px, rgba(100, 100, 200, 0.3) 20px);
        }

        .board-preview-paper {
            background: #faf8f5;
            background-image: 
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(200, 190, 180, 0.3) 19px, rgba(200, 190, 180, 0.3) 20px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(200, 190, 180, 0.3) 19px, rgba(200, 190, 180, 0.3) 20px);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
        }

        .board-preview-cherry {
            background: #c67c65;
            background-image: 
                repeating-linear-gradient(90deg, #c67c65, #b86b54 3px, #c67c65 6px),
                repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(139, 69, 19, 0.3) 19px, rgba(139, 69, 19, 0.3) 20px);
        }

        .board-preview-crystal {
            background: 
                linear-gradient(135deg, rgba(200, 220, 255, 0.3) 0%, rgba(180, 200, 240, 0.2) 100%),
                radial-gradient(circle at 30% 30%, var(--accent-glow) 0%, transparent 60%);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent-primary);
            box-shadow: 
                0 5px 20px var(--accent-glow),
                inset 0 0 30px rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }
        
        .board-preview-crystal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(45deg, transparent 40%, var(--accent-glow) 41%, transparent 42%),
                linear-gradient(-45deg, transparent 40%, var(--accent-glow) 41%, transparent 42%);
            background-size: 20px 20px;
            opacity: 0.1;
        }

        .color-customizer {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .color-picker-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-picker-group label {
            color: var(--accent-light);
            font-weight: 600;
            min-width: 130px;
        }

        .color-picker-group input[type="color"] {
            width: 60px;
            height: 40px;
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }

        .reset-color-btn {
            background: rgba(100, 181, 246, 0.2);
            color: var(--accent-light);
            border: 2px solid var(--accent-primary);
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.3s;
        }

        .reset-color-btn:hover {
            background: rgba(100, 181, 246, 0.3);
            transform: translateY(-2px);
        }

        .bot-settings {
            background: rgba(32, 58, 67, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            border: 1px solid rgba(100, 181, 246, 0.3);
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .setting-group label {
            font-weight: 600;
            color: #e3f2fd;
            font-size: clamp(0.85em, 2.5vw, 0.95em);
        }

        .setting-group select {
            padding: 8px 12px;
            border: 2px solid #64b5f6;
            border-radius: 6px;
            background: rgba(15, 32, 39, 0.9);
            color: #e3f2fd;
            font-size: clamp(0.85em, 2.5vw, 0.95em);
            font-weight: 600;
            cursor: pointer;
            min-width: 120px;
        }

        .setting-group select:focus {
            outline: none;
            border-color: #90caf9;
            box-shadow: 0 0 0 3px rgba(100, 181, 246, 0.2);
        }

        /* Mobile optimizations */
        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
                border-radius: 15px;
            }

            .board {
                padding: 15px;
            }

            .controls {
                width: 100%;
            }

            button {
                flex: 1;
                min-width: 80px;
            }

            .rules {
                font-size: 0.8em;
            }

            .rules ul {
                margin-left: 15px;
            }
        }

        @media (max-width: 400px) {
            .board {
                padding: 10px;
            }
        }

        /* Name input modal */
        .name-input-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(15, 32, 39, 0.98);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 1001;
            transition: transform 0.3s;
            text-align: center;
            min-width: 400px;
            max-width: 90vw;
            border: 2px solid var(--accent-primary);
        }

        .name-input-modal.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .name-input-modal h3 {
            color: var(--accent-primary);
            margin-bottom: 20px;
            font-size: 1.5em;
            text-shadow: 0 0 20px var(--accent-glow);
        }

        .name-input-modal p {
            color: var(--accent-light);
            margin-bottom: 20px;
        }

        .name-input-modal input {
            width: 100%;
            padding: 12px 20px;
            font-size: 1.1em;
            border: 2px solid var(--accent-primary);
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            background: rgba(32, 58, 67, 0.8);
            color: var(--accent-light);
        }

        .name-input-modal input:focus {
            outline: none;
            border-color: var(--accent-secondary);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .name-input-modal button {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .name-input-modal button:hover {
            background: linear-gradient(135deg, #2a5298 0%, #3764c7 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(42, 82, 152, 0.5);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.show {
            display: block;
        }

        .leaderboard-btn {
            background: linear-gradient(135deg, #2d5016 0%, #3d6b1f 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .leaderboard-btn:hover {
            background: linear-gradient(135deg, #3d6b1f 0%, #4d8528 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(61, 107, 31, 0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1> CARO GAME</h1>
        <div class="subtitle">Five in a Row  1919 Grid</div>
        
        <div class="info-panel">
            <div class="current-player">
                <div class="player-indicator black" id="playerIndicator"></div>
                <span id="playerText">Black's Turn</span>
            </div>
            <div class="top-controls">
                <a href="leaderboard.html" style="text-decoration: none;">
                    <button class="leaderboard-btn">
                         View Leaderboard
                    </button>
                </a>
                <button class="settings-btn" onclick="toggleSettings()">
                     Settings
                </button>
            </div>
            <div class="top-controls" style="margin-top: 0;">
                <button class="new-game-btn" onclick="resetGame()">
                     New Game
                </button>
            </div>

            <div class="settings-panel" id="settingsPanel" style="display: none;">
                <!-- Bead Set Selector -->
                <div class="settings-section">
                    <h3> Stone Style</h3>
                    <div class="bead-sets">
                        <button class="bead-set-btn active" onclick="setBeadSet('classic', this)" data-set="classic">
                            <div class="bead-preview">
                                <div class="preview-stone black-classic"></div>
                                <div class="preview-stone white-classic"></div>
                            </div>
                            <span>Classic</span>
                        </button>
                        <button class="bead-set-btn" onclick="setBeadSet('flat', this)" data-set="flat">
                            <div class="bead-preview">
                                <div class="preview-stone black-flat"></div>
                                <div class="preview-stone white-flat"></div>
                            </div>
                            <span>Flat</span>
                        </button>
                        <button class="bead-set-btn" onclick="setBeadSet('neon', this)" data-set="neon">
                            <div class="bead-preview">
                                <div class="preview-stone black-neon"></div>
                                <div class="preview-stone white-neon"></div>
                            </div>
                            <span>Neon</span>
                        </button>
                        <button class="bead-set-btn" onclick="setBeadSet('crystal', this)" data-set="crystal">
                            <div class="bead-preview">
                                <div class="preview-stone black-crystal"></div>
                                <div class="preview-stone white-crystal"></div>
                            </div>
                            <span>Crystal</span>
                        </button>
                        <button class="bead-set-btn" onclick="setBeadSet('metal', this)" data-set="metal">
                            <div class="bead-preview">
                                <div class="preview-stone black-metal"></div>
                                <div class="preview-stone white-metal"></div>
                            </div>
                            <span>Metal</span>
                        </button>
                        <button class="bead-set-btn" onclick="setBeadSet('gem', this)" data-set="gem">
                            <div class="bead-preview">
                                <div class="preview-stone black-gem"></div>
                                <div class="preview-stone white-gem"></div>
                            </div>
                            <span>Gem</span>
                        </button>
                        <button class="bead-set-btn" onclick="setBeadSet('plasma', this)" data-set="plasma">
                            <div class="bead-preview">
                                <div class="preview-stone black-plasma"></div>
                                <div class="preview-stone white-plasma"></div>
                            </div>
                            <span>Plasma</span>
                        </button>
                        <button class="bead-set-btn" onclick="setBeadSet('paper', this)" data-set="paper">
                            <div class="bead-preview">
                                <div class="preview-stone black-paper"></div>
                                <div class="preview-stone white-paper"></div>
                            </div>
                            <span>Paper</span>
                        </button>
                    </div>
                </div>

                <!-- Board Style Selector -->
                <div class="settings-section">
                    <h3> Board Style</h3>
                    <div class="board-styles">
                        <button class="board-style-btn active" onclick="setBoardStyle('classic', this)" data-style="classic">
                            <div class="board-preview-wrapper">
                                <div class="board-preview board-preview-classic"></div>
                            </div>
                            <div class="board-label">
                                <span>Classic</span>
                            </div>
                        </button>
                        <button class="board-style-btn" onclick="setBoardStyle('marble', this)" data-style="marble">
                            <div class="board-preview-wrapper">
                                <div class="board-preview board-preview-marble"></div>
                            </div>
                            <div class="board-label">
                                <span>Flat</span>
                            </div>
                        </button>
                        <button class="board-style-btn" onclick="setBoardStyle('neon', this)" data-style="neon">
                            <div class="board-preview-wrapper">
                                <div class="board-preview board-preview-neon"></div>
                            </div>
                            <div class="board-label">
                                <span>Neon</span>
                            </div>
                        </button>
                        <button class="board-style-btn" onclick="setBoardStyle('crystal', this)" data-style="crystal">
                            <div class="board-preview-wrapper">
                                <div class="board-preview board-preview-crystal"></div>
                            </div>
                            <div class="board-label">
                                <span>Crystal</span>
                            </div>
                        </button>
                        <button class="board-style-btn" onclick="setBoardStyle('metal', this)" data-style="metal">
                            <div class="board-preview-wrapper">
                                <div class="board-preview board-preview-metal"></div>
                            </div>
                            <div class="board-label">
                                <span>Metal</span>
                            </div>
                        </button>
                        <button class="board-style-btn" onclick="setBoardStyle('stone', this)" data-style="stone">
                            <div class="board-preview-wrapper">
                                <div class="board-preview board-preview-stone"></div>
                            </div>
                            <div class="board-label">
                                <span>Stone</span>
                            </div>
                        </button>
                        <button class="board-style-btn" onclick="setBoardStyle('space', this)" data-style="space">
                            <div class="board-preview-wrapper">
                                <div class="board-preview board-preview-space"></div>
                            </div>
                            <div class="board-label">
                                <span>Plasma</span>
                            </div>
                        </button>
                        <button class="board-style-btn" onclick="setBoardStyle('paper', this)" data-style="paper">
                            <div class="board-preview-wrapper">
                                <div class="board-preview board-preview-paper"></div>
                            </div>
                            <div class="board-label">
                                <span>Paper</span>
                            </div>
                        </button>
                    </div>
                </div>

                <!-- Game Mode -->
                <div class="settings-section">
                    <h3> Game Mode</h3>
                    <div class="mode-options">
                        <button class="mode-btn active" onclick="toggleGameMode()" id="gameModeBtn">
                            <span class="mode-icon"></span>
                            <span class="mode-text">Player vs Player</span>
                        </button>
                    </div>
                </div>

                <!-- Bot Settings (shown only in PvB mode) -->
                <div class="settings-section" id="botSettingsSection" style="display: none;">
                    <h3> Bot Configuration</h3>
                    <div class="bot-config">
                        <div class="config-row">
                            <label for="botLevel">Difficulty:</label>
                            <select id="botLevel" onchange="updateBotSettings()">
                                <option value="easy"> Easy</option>
                                <option value="medium" selected> Medium</option>
                                <option value="hard"> Hard</option>
                                <option value="expert"> Expert</option>
                            </select>
                        </div>
                        <div class="config-row">
                            <label for="botStyleSelect">Playing Style:</label>
                            <select id="botStyleSelect" onchange="updateBotSettings()">
                                <option value="random" selected> Random</option>
                                <option value="aggressive"> Aggressive</option>
                                <option value="defensive"> Defensive</option>
                                <option value="balanced"> Balanced</option>
                                <option value="tricky"> Tricky</option>
                                <option value="patient"> Patient</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Game Rules -->
                <div class="settings-section">
                    <h3> Game Rules</h3>
                    <div class="rules-options">
                        <button class="rule-btn" onclick="toggleBlockedRule()" id="blockedRuleBtn">
                            <span class="rule-icon"></span>
                            <span class="rule-text">Blocked Rule: <strong>ON</strong></span>
                        </button>
                        <button class="rule-btn" onclick="toggleThreatAlert()" id="threatAlertBtn">
                            <span class="rule-icon"></span>
                            <span class="rule-text">Threat Alert: <strong>OFF</strong></span>
                        </button>
                    </div>
                </div>

                <!-- Sound Settings -->
                <div class="settings-section">
                    <h3> Sound Settings</h3>
                    <div class="sound-settings">
                        <button class="rule-btn" onclick="toggleSound()" id="soundToggleBtn">
                            <span class="rule-icon"></span>
                            <span class="rule-text">Sound: <strong>ON</strong></span>
                        </button>
                        <div class="volume-control">
                            <label for="volumeSlider">
                                <span></span> Volume: <span id="volumeValue">50</span>%
                            </label>
                            <input type="range" id="volumeSlider" min="0" max="100" value="50" 
                                   oninput="updateVolume(this.value)" class="volume-slider">
                        </div>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="current-player">
                    <div class="player-indicator black" id="playerIndicator"></div>
                    <span id="playerText">Black's Turn</span>
                </div>
                <div class="variant-info" id="variantInfo">Blocked lines don't count as wins</div>
            </div>
        </div>

        <div class="board-container">
            <div class="board" id="board"></div>
        </div>

        <div class="message" id="message"></div>
        <div class="variant-info" id="variantInfo">Blocked lines don't count as wins</div>

        <div class="rules">
            <h3> Quick Rules</h3>
            <ul>
                <li>Get <strong>5 or more consecutive stones</strong> in any direction (horizontal, vertical, or diagonal)</li>
                <li><strong>Blocked Rule ON:</strong> Lines blocked on both ends () don't count as wins</li>
                <li><strong>Blocked Rule OFF:</strong> Any 5+ in a row wins, even if blocked on both ends</li>
                <li><strong>Threat Alert:</strong> Highlights stones with a red ring that would become winning combinations if one more stone is added</li>
                <li><strong>PvP Mode:</strong> Two players take turns, Black always starts first</li>
                <li><strong>PvB Mode:</strong> Play against AI. First game: random starter. Next games: loser of previous game starts first</li>
            </ul>
            <h3> Bot Settings</h3>
            <ul>
                <li><strong>Easy:</strong> Makes frequent mistakes, limited search depth</li>
                <li><strong>Medium:</strong> Solid play with occasional errors</li>
                <li><strong>Hard:</strong> Strong player, rarely makes mistakes</li>
                <li><strong>Expert:</strong> Maximum search depth, no mistakes, perfect blocked rule awareness</li>
            </ul>
            <ul>
                <li><strong>Aggressive:</strong> Focuses on creating threats (1.5x offense, 0.7x defense)</li>
                <li><strong>Defensive:</strong> Prioritizes blocking (0.7x offense, 1.5x defense)</li>
                <li><strong>Balanced:</strong> Equal offense and defense</li>
                <li><strong>Tricky:</strong> Creates complex positions, unpredictable moves</li>
                <li><strong>Patient:</strong> Solid, safe moves with strong defense</li>
                <li><strong>Random:</strong> Bot randomly picks a style each game</li>
            </ul>
            <p><strong> Blocked Rule Awareness:</strong> Bot understands when Blocked Rule is ON/OFF and adjusts strategy. With Blocked Rule ON, bot avoids creating blocked patterns and focuses on open-ended threats.</p>
        </div>
    </div>

    <!-- Name Input Modal -->
    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="name-input-modal" id="nameInputModal">
        <h3> Congratulations!</h3>
        <p>Enter your name for the leaderboard:</p>
        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20" />
        <button onclick="submitScore()">Submit Score</button>
    </div>

    <script>
        const BOARD_SIZE = 19;
        let board = [];
        let currentPlayer = 'black';
        let gameOver = false;
        let blockedRule = true; // true = blocked lines don't win, false = blocked lines can win
        let threatAlert = false; // true = show threat detection, false = hide threats
        let gameMode = 'pvp'; // 'pvp' = player vs player, 'pvb' = player vs bot
        let botThinking = false; // prevent multiple bot moves at once
        let botColor = null; // 'black' or 'white' - which color the bot plays
        let humanColor = null; // 'black' or 'white' - which color the human plays
        let firstBotGame = true; // true = first game in bot mode (randomize starter)
        let botStyle = null; // 'aggressive', 'defensive', 'balanced', 'tricky', 'patient'
        let botLevel = 'medium'; // 'easy', 'medium', 'hard', 'expert'
        let botStylePreference = 'random'; // User's style preference
        let lastGameResult = null; // Store winner info for leaderboard

        // Star points positions for 19x19 Go board
        const STAR_POINTS = [
            [3, 3], [3, 9], [3, 15],
            [9, 3], [9, 9], [9, 15],
            [15, 3], [15, 9], [15, 15]
        ];

        // Initialize the game
        function initGame() {
            board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
            gameOver = false;
            botThinking = false;
            
            // Determine starting player based on game mode
            if (gameMode === 'pvb') {
                // Assign bot playing style for this game
                if (botStylePreference === 'random') {
                    const styles = ['aggressive', 'defensive', 'balanced', 'tricky', 'patient'];
                    botStyle = styles[Math.floor(Math.random() * styles.length)];
                } else {
                    botStyle = botStylePreference;
                }
                
                if (firstBotGame) {
                    // First game in bot mode: randomize who starts
                    const botStarts = Math.random() < 0.5;
                    botColor = botStarts ? 'black' : 'white';
                    humanColor = botStarts ? 'white' : 'black';
                    currentPlayer = 'black'; // Black always starts first
                    firstBotGame = false;
                }
                // For subsequent games, colors are already set (loser starts)
                currentPlayer = 'black'; // Black always starts first
            } else {
                // PvP mode: always start with black
                currentPlayer = 'black';
                botColor = null;
                humanColor = null;
                botStyle = null;
            }
            
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            // Remove all old board style classes but keep the base 'board' class
            boardElement.className = 'board';
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Add star point class for traditional Go board markers
                    const isStarPoint = STAR_POINTS.some(([r, c]) => r === row && c === col);
                    if (isStarPoint) {
                        cell.classList.add('star-point');
                        const starDot = document.createElement('div');
                        starDot.className = 'star-dot';
                        cell.appendChild(starDot);
                    }
                    
                    // Add hover shadow element
                    const hoverShadow = document.createElement('div');
                    hoverShadow.className = `hover-shadow shadow-${currentBeadSet}`;
                    cell.appendChild(hoverShadow);
                    
                    cell.onclick = () => makeMove(row, col);
                    
                    // Add touch support for mobile
                    cell.ontouchend = (e) => {
                        e.preventDefault();
                        makeMove(row, col);
                    };

                    // Prevent context menu on long press
                    cell.oncontextmenu = (e) => {
                        e.preventDefault();
                        return false;
                    };

                    // Update hover shadow color based on current player
                    cell.onmouseenter = () => {
                        if (!gameOver && board[row][col] === null) {
                            hoverShadow.className = `hover-shadow ${currentPlayer} shadow-${currentBeadSet}`;
                        }
                    };
                    
                    // Touch start to show preview
                    cell.ontouchstart = (e) => {
                        if (!gameOver && board[row][col] === null) {
                            hoverShadow.className = `hover-shadow ${currentPlayer} shadow-${currentBeadSet}`;
                            hoverShadow.style.display = 'block';
                        }
                    };
                    
                    // Touch move to hide preview if moved away
                    cell.ontouchmove = (e) => {
                        hoverShadow.style.display = 'none';
                    };
                    
                    // Touch cancel to hide preview
                    cell.ontouchcancel = (e) => {
                        hoverShadow.style.display = 'none';
                    };
                    
                    boardElement.appendChild(cell);
                }
            }
            
            // Apply current board style
            boardElement.classList.add(`board-${currentBoardStyle}`);
            
            updateUI();
            
            // If bot mode and bot starts (black), make first move
            if (gameMode === 'pvb' && botColor === 'black') {
                botThinking = true;
                setTimeout(() => {
                    makeBotMove();
                    botThinking = false;
                }, 500);
            }
        }

        // Sound Effects
        let soundEnabled = true;
        let soundVolume = 0.5; // 0 to 1
        
        // Ultra-realistic material sounds with noise components
        function playPlaceSound() {
            if (!soundEnabled) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;
                
                // Wood - deep thunk with initial impact noise
                if (currentBeadSet === 'wood') {
                    // Impact noise burst
                    const noise = audioContext.createBufferSource();
                    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.02, audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * 0.3;
                    }
                    noise.buffer = noiseBuffer;
                    
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    noiseFilter.type = 'lowpass';
                    noiseFilter.frequency.value = 800;
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    
                    noiseGain.gain.setValueAtTime(0.4 * soundVolume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
                    noise.start(now);
                    
                    // Resonant body
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(180, now + 0.15);
                    osc.type = 'triangle';
                    
                    gain.gain.setValueAtTime(0.35 * soundVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                    
                    osc.start(now);
                    osc.stop(now + 0.15);
                    return;
                }
                
                // Stone/Classic/Marble - authentic stone click with contact noise
                if (currentBeadSet === 'classic' || currentBeadSet === 'marble' || currentBeadSet === 'glossy') {
                    // Sharp contact noise
                    const noise = audioContext.createBufferSource();
                    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.015, audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * 0.4;
                    }
                    noise.buffer = noiseBuffer;
                    
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.value = 2000;
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    
                    noiseGain.gain.setValueAtTime(0.5 * soundVolume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.015);
                    noise.start(now);
                    
                    // Stone resonance
                    const freq = currentBeadSet === 'glossy' ? 900 : 750;
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    osc.frequency.setValueAtTime(freq, now);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.5, now + 0.1);
                    osc.type = 'sine';
                    
                    gain.gain.setValueAtTime(0.25 * soundVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    
                    osc.start(now);
                    osc.stop(now + 0.1);
                    return;
                }
                
                // Glass - realistic glass tap with attack transient
                if (currentBeadSet === 'glass') {
                    // Sharp attack noise
                    const noise = audioContext.createBufferSource();
                    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.005, audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * 0.3;
                    }
                    noise.buffer = noiseBuffer;
                    
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.value = 4000;
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    
                    noiseGain.gain.setValueAtTime(0.6 * soundVolume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.005);
                    noise.start(now);
                    
                    // Glass harmonics with slight frequency wobble
                    const frequencies = [2200, 4400, 6600];
                    const gains = [0.35, 0.18, 0.09];
                    
                    frequencies.forEach((freq, index) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        
                        osc.frequency.setValueAtTime(freq, now);
                        osc.frequency.setValueAtTime(freq * 1.01, now + 0.01);
                        osc.frequency.setValueAtTime(freq, now + 0.02);
                        osc.type = 'sine';
                        
                        const vol = gains[index] * soundVolume;
                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(vol, now + 0.005);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                        
                        osc.start(now);
                        osc.stop(now + 0.35);
                    });
                    return;
                }
                
                // Metal - metallic clang with noise
                if (currentBeadSet === 'metal') {
                    // Metallic contact noise
                    const noise = audioContext.createBufferSource();
                    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.01, audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * 0.4;
                    }
                    noise.buffer = noiseBuffer;
                    
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.value = 3000;
                    noiseFilter.Q.value = 2;
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    
                    noiseGain.gain.setValueAtTime(0.5 * soundVolume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.01);
                    noise.start(now);
                    
                    // Metal ring
                    const frequencies = [1300, 2600, 3900, 5200];
                    const gains = [0.3, 0.15, 0.08, 0.04];
                    
                    frequencies.forEach((freq, index) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        
                        osc.frequency.value = freq;
                        osc.type = 'triangle';
                        
                        const vol = gains[index] * soundVolume;
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                        
                        osc.start(now);
                        osc.stop(now + 0.4);
                    });
                    return;
                }
                
                // Crystal - pure crystalline ring
                if (currentBeadSet === 'crystal') {
                    // Tiny attack
                    const noise = audioContext.createBufferSource();
                    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.003, audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * 0.2;
                    }
                    noise.buffer = noiseBuffer;
                    
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.value = 5000;
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    
                    noiseGain.gain.setValueAtTime(0.4 * soundVolume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.003);
                    noise.start(now);
                    
                    // Crystal harmonics
                    const frequencies = [2600, 5200, 7800, 10400];
                    const gains = [0.25, 0.12, 0.06, 0.03];
                    
                    frequencies.forEach((freq, index) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        
                        const vol = gains[index] * soundVolume;
                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(vol, now + 0.003);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                        
                        osc.start(now);
                        osc.stop(now + 0.5);
                    });
                    return;
                }
                
                // Ceramic - clean tap
                if (currentBeadSet === 'ceramic') {
                    const noise = audioContext.createBufferSource();
                    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.008, audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * 0.3;
                    }
                    noise.buffer = noiseBuffer;
                    
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.value = 3000;
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    
                    noiseGain.gain.setValueAtTime(0.4 * soundVolume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.008);
                    noise.start(now);
                    
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    osc.frequency.setValueAtTime(1200, now);
                    osc.frequency.exponentialRampToValueAtTime(650, now + 0.09);
                    osc.type = 'sine';
                    
                    gain.gain.setValueAtTime(0.28 * soundVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
                    
                    osc.start(now);
                    osc.stop(now + 0.09);
                    return;
                }
                
                // Gem - precious stone chime
                if (currentBeadSet === 'gem') {
                    const frequencies = [1900, 3800, 5700];
                    const gains = [0.3, 0.15, 0.08];
                    
                    frequencies.forEach((freq, index) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        
                        const vol = gains[index] * soundVolume;
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                        
                        osc.start(now);
                        osc.stop(now + 0.18);
                    });
                    return;
                }
                
                // Fallback for other styles
                const profiles = {
                    flat: { freq: [600, 280], type: 'triangle', duration: 0.13 },
                    neon: { freq: [1200, 900], type: 'square', duration: 0.07 },
                    plasma: { freq: [1400, 1100], type: 'square', duration: 0.1 },
                    space: { freq: [1100, 250], type: 'sawtooth', duration: 0.3 },
                    paper: { freq: [400, 200], type: 'triangle', duration: 0.06 }
                };
                
                const profile = profiles[currentBeadSet];
                if (profile) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    osc.frequency.setValueAtTime(profile.freq[0], now);
                    osc.frequency.exponentialRampToValueAtTime(profile.freq[1], now + profile.duration * 0.7);
                    osc.type = profile.type;
                    
                    gain.gain.setValueAtTime(0.25 * soundVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + profile.duration);
                    
                    osc.start(now);
                    osc.stop(now + profile.duration);
                }
                
            } catch (e) {
                // Audio not supported - silent fail
            }
        }
        
        function playWinSound() {
            if (!soundEnabled) return;

            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6

                notes.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';

                    const startTime = audioContext.currentTime + index * 0.15;
                    const volume = 0.2 * soundVolume;
                    gainNode.gain.setValueAtTime(volume, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);

                    oscillator.start(startTime);
                    oscillator.stop(startTime + 0.3);
                });
            } catch (e) {
                // Audio not supported - silent fail
            }
        }

        function playUndoSound() {
            if (!soundEnabled) return;

            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;

                // Gentle reverse sound - descending tone
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Start high and go low for a "rewind" feel
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.15);
                oscillator.type = 'sine';

                const volume = 0.15 * soundVolume;
                gainNode.gain.setValueAtTime(volume, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                oscillator.start(now);
                oscillator.stop(now + 0.15);
            } catch (e) {
                // Audio not supported - silent fail
            }
        }

        function playIllegalMoveSound() {
            if (!soundEnabled) return;

            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;

                // Error buzz - two quick low tones
                for (let i = 0; i < 2; i++) {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 200;
                    oscillator.type = 'sawtooth';

                    const startTime = now + (i * 0.08);
                    const volume = 0.2 * soundVolume;
                    gainNode.gain.setValueAtTime(volume, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.06);

                    oscillator.start(startTime);
                    oscillator.stop(startTime + 0.06);
                }
            } catch (e) {
                // Audio not supported - silent fail
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;

            // Save to localStorage
            try {
                localStorage.setItem('gomokuSoundEnabled', JSON.stringify(soundEnabled));
            } catch (e) {
                console.error('Failed to save sound preference:', e);
            }

            // Update settings panel button
            const btn = document.getElementById('soundToggleBtn');
            if (btn) {
                const icon = btn.querySelector('.rule-icon');
                const text = btn.querySelector('.rule-text strong');
                if (icon) icon.textContent = soundEnabled ? '' : '';
                if (text) text.textContent = soundEnabled ? 'ON' : 'OFF';
            }

            // Update top controls button
            const topBtn = document.getElementById('topSoundToggle');
            if (topBtn) {
                topBtn.textContent = soundEnabled ? '' : '';
                topBtn.title = soundEnabled ? 'Sound: ON' : 'Sound: OFF';
            }
        }

        function updateVolume(value) {
            soundVolume = value / 100;
            document.getElementById('volumeValue').textContent = value;

            // Save to localStorage
            try {
                localStorage.setItem('gomokuSoundVolume', value);
            } catch (e) {
                console.error('Failed to save volume preference:', e);
            }
        }

        function loadSoundPreferences() {
            try {
                // Load sound enabled state
                const savedSoundEnabled = localStorage.getItem('gomokuSoundEnabled');
                if (savedSoundEnabled !== null) {
                    soundEnabled = JSON.parse(savedSoundEnabled);

                    // Update settings panel button
                    const btn = document.getElementById('soundToggleBtn');
                    if (btn) {
                        const icon = btn.querySelector('.rule-icon');
                        const text = btn.querySelector('.rule-text strong');
                        if (icon) icon.textContent = soundEnabled ? '' : '';
                        if (text) text.textContent = soundEnabled ? 'ON' : 'OFF';
                    }

                    // Update top controls button
                    const topBtn = document.getElementById('topSoundToggle');
                    if (topBtn) {
                        topBtn.textContent = soundEnabled ? '' : '';
                        topBtn.title = soundEnabled ? 'Sound: ON' : 'Sound: OFF';
                    }
                }

                // Load volume
                const savedVolume = localStorage.getItem('gomokuSoundVolume');
                if (savedVolume !== null) {
                    const volumeValue = parseInt(savedVolume);
                    soundVolume = volumeValue / 100;

                    const slider = document.getElementById('volumeSlider');
                    if (slider) slider.value = volumeValue;

                    const valueDisplay = document.getElementById('volumeValue');
                    if (valueDisplay) valueDisplay.textContent = volumeValue;
                }
            } catch (e) {
                console.error('Failed to load sound preferences:', e);
            }
        }

        // Make a move
        function makeMove(row, col, isBotMove = false) {
            // Check for illegal moves and play sound if user tries to place on occupied cell
            if (board[row][col] !== null) {
                if (!isBotMove) playIllegalMoveSound();
                return;
            }

            if (gameOver) return;

            // In bot mode, prevent human from moving during bot's turn (but allow bot moves)
            if (!isBotMove && gameMode === 'pvb' && currentPlayer === botColor) return;

            // Prevent human moves while bot is thinking
            if (!isBotMove && botThinking) return;
            
            board[row][col] = currentPlayer;
            
            // Play placement sound
            playPlaceSound();
            
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.classList.add('has-stone');
            
            const stone = document.createElement('div');
            stone.className = `stone ${currentPlayer} stone-${currentBeadSet}`;
            
            // Generate random crystal shape if using crystal bead set
            if (currentBeadSet === 'crystal') {
                const randomShape = generateRandomCrystalShape();
                stone.style.clipPath = randomShape;
            }
            
            cell.appendChild(stone);
            
            if (checkWin(row, col)) {
                gameOver = true;
                const winner = currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);

                // Store result for leaderboard
                let shouldPromptForName = false;

                // In bot mode, show correct win message and update colors for next game
                if (gameMode === 'pvb') {
                    // Check who won BEFORE swapping colors
                    const humanWon = currentPlayer === humanColor;

                    // Now update colors so loser starts next game
                    const loserColor = currentPlayer === 'black' ? 'white' : 'black';
                    // Loser gets black (starts first) in next game
                    if (loserColor === humanColor) {
                        botColor = 'white';
                        humanColor = 'black';
                    } else {
                        botColor = 'black';
                        humanColor = 'white';
                    }

                    // Display win message based on who won
                    if (humanWon) {
                        document.getElementById('message').innerHTML = ` You (${winner}) Win!`;
                        shouldPromptForName = true;
                    } else {
                        document.getElementById('message').innerHTML = ` Bot (${winner}) Wins!`;
                    }
                } else {
                    document.getElementById('message').innerHTML = ` ${winner} Wins!`;
                    shouldPromptForName = true;
                }

                // Play win sound
                playWinSound();

                document.getElementById('message').classList.add('win-message');
                updateThreats(); // Clear threats on game over

                // Prompt for name and save to leaderboard if human won
                if (shouldPromptForName) {
                    lastGameResult = {
                        winner: winner,
                        date: new Date().toISOString()
                    };

                    // Show name input modal
                    document.getElementById('modalOverlay').classList.add('show');
                    document.getElementById('nameInputModal').classList.add('show');
                    document.getElementById('playerNameInput').value = '';
                    document.getElementById('playerNameInput').focus();

                    // Allow Enter key to submit
                    document.getElementById('playerNameInput').onkeypress = function(e) {
                        if (e.key === 'Enter') {
                            submitScore();
                        }
                    };
                }

                return;
            }
            
            if (isBoardFull()) {
                gameOver = true;
                document.getElementById('message').innerHTML = ` It's a Draw!`;
                updateThreats(); // Clear threats on game over
                return;
            }
            
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            updateUI();
            updateThreats(); // Update threat detection after move
            
            // If bot mode and it's bot's turn, make bot move
            if (gameMode === 'pvb' && currentPlayer === botColor && !gameOver) {
                botThinking = true;
                setTimeout(() => {
                    makeBotMove();
                    botThinking = false;
                }, 500); // Small delay to make it feel more natural
            }
        }

        // Check if the current move wins the game
        function checkWin(row, col) {
            const directions = [
                [{r: 0, c: 1}, {r: 0, c: -1}],   // Horizontal
                [{r: 1, c: 0}, {r: -1, c: 0}],   // Vertical
                [{r: 1, c: 1}, {r: -1, c: -1}],  // Diagonal \
                [{r: 1, c: -1}, {r: -1, c: 1}]   // Diagonal /
            ];
            
            const player = board[row][col];
            
            for (let [dir1, dir2] of directions) {
                const count1 = countStones(row, col, dir1.r, dir1.c, player);
                const count2 = countStones(row, col, dir2.r, dir2.c, player);
                const total = count1 + count2 + 1; // +1 for the current stone
                
                // Check if line is blocked on both ends
                const blocked1 = isBlocked(row, col, dir1.r, dir1.c, count1, player);
                const blocked2 = isBlocked(row, col, dir2.r, dir2.c, count2, player);
                const bothEndsBlocked = blocked1 && blocked2;
                
                // Apply blocked rule only if it's enabled
                const isValidWin = blockedRule ? !bothEndsBlocked : true;
                
                // Win with 5 or more in a row
                if (total >= 5 && isValidWin) {
                    return true;
                }
            }
            
            return false;
        }

        // Find all stones that are part of threats (would create a win if one more stone is added)
        function findThreats() {
            const threats = new Set();
            
            // Check every empty position
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === null) {
                        // Check if either player can win by placing here
                        for (const player of ['black', 'white']) {
                            // Temporarily place stone
                            board[row][col] = player;
                            
                            if (checkWin(row, col)) {
                                // Find the 4 existing stones that would become a winning 5
                                const threatStones = findThreatStones(row, col, player);
                                threatStones.forEach(pos => threats.add(`${pos.row},${pos.col}`));
                            }
                            
                            // Remove temporary stone
                            board[row][col] = null;
                        }
                    }
                }
            }
            
            return threats;
        }

        // Find the existing stones that would be part of a winning line if a stone is placed at (row, col)
        function findThreatStones(row, col, player) {
            const directions = [
                [{r: 0, c: 1}, {r: 0, c: -1}],   // Horizontal
                [{r: 1, c: 0}, {r: -1, c: 0}],   // Vertical
                [{r: 1, c: 1}, {r: -1, c: -1}],  // Diagonal \
                [{r: 1, c: -1}, {r: -1, c: 1}]   // Diagonal /
            ];
            
            const threatStones = [];
            
            // Temporarily place the stone
            board[row][col] = player;
            
            for (let [dir1, dir2] of directions) {
                const stones1 = getStones(row, col, dir1.r, dir1.c, player);
                const stones2 = getStones(row, col, dir2.r, dir2.c, player);
                const allStones = [...stones1, ...stones2];
                const total = allStones.length + 1; // +1 for the placed stone
                
                // Check if this would be a winning line
                const count1 = stones1.length;
                const count2 = stones2.length;
                const blocked1 = isBlocked(row, col, dir1.r, dir1.c, count1, player);
                const blocked2 = isBlocked(row, col, dir2.r, dir2.c, count2, player);
                const bothEndsBlocked = blocked1 && blocked2;
                const isValidWin = blockedRule ? !bothEndsBlocked : true;
                
                if (total >= 5 && isValidWin) {
                    // Add all stones except the one we're testing
                    allStones.forEach(stone => {
                        if (stone.row !== row || stone.col !== col) {
                            threatStones.push(stone);
                        }
                    });
                }
            }
            
            // Remove the temporary stone
            board[row][col] = null;
            
            return threatStones;
        }

        // Get all consecutive stones in one direction (returns array of positions)
        function getStones(row, col, dRow, dCol, player) {
            const stones = [];
            let r = row + dRow;
            let c = col + dCol;
            
            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
                stones.push({row: r, col: c});
                r += dRow;
                c += dCol;
            }
            
            return stones;
        }

        // Update threat highlights on the board
        function updateThreats() {
            // Remove all existing threat classes
            document.querySelectorAll('.stone').forEach(stone => {
                stone.classList.remove('threat');
            });
            
            if (!threatAlert || gameOver) return;
            
            // Find and highlight threats
            const threats = findThreats();
            threats.forEach(pos => {
                const [row, col] = pos.split(',').map(Number);
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                const stone = cell?.querySelector('.stone');
                if (stone) {
                    stone.classList.add('threat');
                }
            });
        }

        // Bot AI - Make a move for the bot
        function makeBotMove() {
            const move = findBestMove();
            if (move) {
                makeMove(move.row, move.col, true); // Pass true to indicate this is a bot move
            }
        }

        // Pattern scores for position evaluation (adjusted by difficulty)
        const PATTERNS = {
            FIVE: 100000,
            OPEN_FOUR: 50000,      // Increased - this is almost a win
            FOUR: 8000,            // Increased
            OPEN_THREE: 5000,      // Increased - very dangerous
            THREE: 1000,           // Increased
            OPEN_TWO: 200,         // Increased
            TWO: 80,
            ONE: 15
        };

        // Get difficulty multipliers
        function getDifficultySettings() {
            switch(botLevel) {
                case 'easy':
                    return {
                        searchRadius: 1,
                        candidateCount: 10,
                        randomness: 0.4,
                        mistakeChance: 0.3,
                        checkMultiThreats: false,
                        lookAhead: 0
                    };
                case 'medium':
                    return {
                        searchRadius: 2,
                        candidateCount: 15,
                        randomness: 0.2,
                        mistakeChance: 0.15,
                        checkMultiThreats: false,
                        lookAhead: 1
                    };
                case 'hard':
                    return {
                        searchRadius: 2,
                        candidateCount: 20,
                        randomness: 0.1,
                        mistakeChance: 0.05,
                        checkMultiThreats: true,
                        lookAhead: 2
                    };
                case 'expert':
                    return {
                        searchRadius: 3,
                        candidateCount: 30,
                        randomness: 0,
                        mistakeChance: 0,
                        checkMultiThreats: true,
                        lookAhead: 3
                    };
                default:
                    return {
                        searchRadius: 2,
                        candidateCount: 15,
                        randomness: 0.2,
                        mistakeChance: 0.15,
                        checkMultiThreats: false,
                        lookAhead: 1
                    };
            }
        }

        // Find the best move for the bot using advanced strategy
        function findBestMove() {
            const botPlayer = botColor;
            const humanPlayer = humanColor;
            const settings = getDifficultySettings();
            
            // 1. ALWAYS win immediately if possible (never skip this)
            const winMove = findWinningMove(botPlayer);
            if (winMove) return winMove;
            
            // 2. ALWAYS block opponent's winning move (never skip this)
            const blockMove = findWinningMove(humanPlayer);
            if (blockMove) return blockMove;
            
            // 3. For Hard/Expert: Check for double threats (VCF - Victory by Continuous Force)
            if (settings.checkMultiThreats) {
                const doubleThreatMove = findDoubleThreatMove(botPlayer);
                if (doubleThreatMove) return doubleThreatMove;
                
                // Block opponent's double threat attempts
                const blockDoubleThreat = findDoubleThreatMove(humanPlayer);
                if (blockDoubleThreat) return blockDoubleThreat;
            }
            
            // 4. For lower difficulties, check for mistakes AFTER critical moves
            if (Math.random() < settings.mistakeChance) {
                const weakMove = findWeakerMove(botPlayer, humanPlayer);
                if (weakMove) return weakMove;
            }
            
            // 5. Use evaluation function to find best move
            return findBestMoveByEvaluation(botPlayer, humanPlayer);
        }

        // Find a move that creates multiple winning threats (fork/double attack)
        function findDoubleThreatMove(player) {
            const candidates = [];
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === null) {
                        // Skip positions too far from action
                        if (!isNearStones(row, col, 3)) continue;
                        
                        // Temporarily place stone
                        board[row][col] = player;
                        
                        // Count how many winning threats this creates
                        let threatCount = 0;
                        const winningPositions = [];
                        
                        for (let r = 0; r < BOARD_SIZE; r++) {
                            for (let c = 0; c < BOARD_SIZE; c++) {
                                if (board[r][c] === null) {
                                    board[r][c] = player;
                                    if (checkWin(r, c)) {
                                        threatCount++;
                                        winningPositions.push({r, c});
                                    }
                                    board[r][c] = null;
                                    
                                    // Early exit if we found 2+ threats
                                    if (threatCount >= 2) {
                                        board[row][col] = null;
                                        return {row, col};
                                    }
                                }
                            }
                        }
                        
                        // Remove temporary stone
                        board[row][col] = null;
                        
                        if (threatCount >= 2) {
                            candidates.push({row, col, threatCount});
                        }
                    }
                }
            }
            
            // Return move that creates most threats
            if (candidates.length > 0) {
                candidates.sort((a, b) => b.threatCount - a.threatCount);
                return candidates[0];
            }
            return null;
        }

        // Check if a line would be blocked on both ends (important when blocked rule is ON)
        function wouldBeBlocked(row, col, dRow, dCol, player, count) {
            if (!blockedRule) return false; // If blocked rule is OFF, doesn't matter
            
            // Check both ends
            const end1Row = row + dRow * (count + 1);
            const end1Col = col + dCol * (count + 1);
            const end2Row = row - dRow * (count + 1);
            const end2Col = col - dCol * (count + 1);
            
            const opponent = player === 'black' ? 'white' : 'black';
            
            let blocked1 = false;
            let blocked2 = false;
            
            // Check end 1
            if (end1Row >= 0 && end1Row < BOARD_SIZE && end1Col >= 0 && end1Col < BOARD_SIZE) {
                blocked1 = board[end1Row][end1Col] === opponent;
            } else {
                blocked1 = true; // Edge counts as blocked
            }
            
            // Check end 2
            if (end2Row >= 0 && end2Row < BOARD_SIZE && end2Col >= 0 && end2Col < BOARD_SIZE) {
                blocked2 = board[end2Row][end2Col] === opponent;
            } else {
                blocked2 = true; // Edge counts as blocked
            }
            
            return blocked1 && blocked2;
        }

        // Check if position is near existing stones
        function isNearStones(row, col, radius) {
            for (let dr = -radius; dr <= radius; dr++) {
                for (let dc = -radius; dc <= radius; dc++) {
                    const r = row + dr;
                    const c = col + dc;
                    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && 
                        board[r][c] !== null) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Find a weaker move (for mistakes at lower difficulty)
        function findWeakerMove(botPlayer, humanPlayer) {
            const settings = getDifficultySettings();
            const candidates = [];
            
            // Just find moves near existing stones
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === null) {
                        let nearStone = false;
                        for (let dr = -2; dr <= 2; dr++) {
                            for (let dc = -2; dc <= 2; dc++) {
                                const r = row + dr;
                                const c = col + dc;
                                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && 
                                    board[r][c] !== null) {
                                    nearStone = true;
                                    break;
                                }
                            }
                            if (nearStone) break;
                        }
                        if (nearStone) {
                            candidates.push({row, col});
                        }
                    }
                }
            }
            
            if (candidates.length > 0) {
                return candidates[Math.floor(Math.random() * candidates.length)];
            }
            return null;
        }

        // Find a move that would result in an immediate win
        function findWinningMove(player) {
            const winningMoves = [];
            
            // Check every empty position on the board
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === null) {
                        // Temporarily place stone
                        board[row][col] = player;
                        
                        // Check if this creates a win
                        if (checkWin(row, col)) {
                            winningMoves.push({row, col});
                        }
                        
                        // Remove temporary stone
                        board[row][col] = null;
                    }
                }
            }
            
            // Return first winning move found (they're all equally good)
            return winningMoves.length > 0 ? winningMoves[0] : null;
        }

        // Find best move using position evaluation with playing style
        function findBestMoveByEvaluation(botPlayer, humanPlayer) {
            const candidates = [];
            const settings = getDifficultySettings();
            const searchRadius = settings.searchRadius;
            
            // Find all empty positions near existing stones
            const emptyNearStones = new Set();
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] !== null) {
                        for (let dr = -searchRadius; dr <= searchRadius; dr++) {
                            for (let dc = -searchRadius; dc <= searchRadius; dc++) {
                                const r = row + dr;
                                const c = col + dc;
                                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && 
                                    board[r][c] === null) {
                                    emptyNearStones.add(`${r},${c}`);
                                }
                            }
                        }
                    }
                }
            }
            
            // If no stones on board, play center
            if (emptyNearStones.size === 0) {
                const center = Math.floor(BOARD_SIZE / 2);
                return {row: center, col: center};
            }
            
            // Evaluate each candidate
            emptyNearStones.forEach(pos => {
                const [row, col] = pos.split(',').map(Number);
                const score = evaluateMove(row, col, botPlayer, humanPlayer);
                candidates.push({row, col, score});
            });
            
            // Sort by score
            candidates.sort((a, b) => b.score - a.score);
            
            // Limit candidates based on difficulty
            const topCandidates = candidates.slice(0, settings.candidateCount);
            
            // Playing style affects move selection
            let selectedIndex = 0;
            
            if (botLevel === 'expert') {
                // Expert always picks the absolute best move (no randomness)
                return topCandidates[0];
            }
            
            if (botStyle === 'aggressive') {
                // Pick best offensive move with slight randomness
                selectedIndex = Math.floor(Math.random() * Math.min(2, topCandidates.length));
            } else if (botStyle === 'defensive') {
                // Consider top moves, prefer ones with good defensive score
                selectedIndex = Math.floor(Math.random() * Math.min(3, topCandidates.length));
            } else if (botStyle === 'balanced') {
                // Add randomness based on difficulty
                const randomRange = Math.ceil(5 * settings.randomness);
                selectedIndex = Math.floor(Math.random() * Math.min(randomRange + 1, topCandidates.length));
            } else if (botStyle === 'tricky') {
                // Sometimes picks 2nd or 3rd best move to be unpredictable
                selectedIndex = Math.floor(Math.random() * Math.min(4, topCandidates.length));
            } else if (botStyle === 'patient') {
                // Prefers solid, safe moves
                selectedIndex = Math.floor(Math.random() * Math.min(2, topCandidates.length));
            }
            
            return topCandidates[selectedIndex];
        }

        // Evaluate a move position
        function evaluateMove(row, col, botPlayer, humanPlayer) {
            let score = 0;
            
            // Offensive score (bot's patterns)
            const offensiveScore = evaluatePlayerPatterns(row, col, botPlayer);
            
            // Defensive score (blocking human's patterns)
            const defensiveScore = evaluatePlayerPatterns(row, col, humanPlayer);
            
            // Critical defense - heavily prioritize blocking open fours and open threes
            let defensiveMultiplier = 1;
            if (defensiveScore >= PATTERNS.OPEN_FOUR) {
                defensiveMultiplier = 3; // Must block open four
            } else if (defensiveScore >= PATTERNS.OPEN_THREE) {
                defensiveMultiplier = 2.5; // Must block open three
            } else if (defensiveScore >= PATTERNS.FOUR) {
                defensiveMultiplier = 2; // Should block four
            }
            
            // Apply style multipliers
            if (botStyle === 'aggressive') {
                score = offensiveScore * 1.5 + defensiveScore * 1.2 * defensiveMultiplier;
            } else if (botStyle === 'defensive') {
                score = offensiveScore * 0.8 + defensiveScore * 1.8 * defensiveMultiplier;
            } else if (botStyle === 'balanced') {
                score = offensiveScore + defensiveScore * defensiveMultiplier;
            } else if (botStyle === 'tricky') {
                // Values creating complex positions
                score = offensiveScore * 1.2 + defensiveScore * 1.1 * defensiveMultiplier;
                // Bonus for creating multiple threats
                if (offensiveScore > PATTERNS.OPEN_THREE) {
                    score *= 1.3;
                }
            } else if (botStyle === 'patient') {
                // Values solid defensive moves with moderate offense
                score = offensiveScore * 0.9 + defensiveScore * 1.5 * defensiveMultiplier;
            }
            
            // Add center bias (less important than patterns)
            const center = Math.floor(BOARD_SIZE / 2);
            const distFromCenter = Math.abs(row - center) + Math.abs(col - center);
            score -= distFromCenter;
            
            return score;
        }

        // Evaluate patterns for a player at position
        function evaluatePlayerPatterns(row, col, player) {
            let score = 0;
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]
            ];
            
            for (const [dRow, dCol] of directions) {
                const pattern = analyzeDirection(row, col, dRow, dCol, player);
                score += getPatternScore(pattern);
            }
            
            return score;
        }

        // Analyze a direction and return pattern info
        function analyzeDirection(row, col, dRow, dCol, player) {
            let consecutive = 0;
            let openEnds = 0;
            let gaps = 0;
            
            // Check positive direction
            let r = row + dRow;
            let c = col + dCol;
            let spaces = 0;
            let endReached = false;
            
            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && spaces < 5) {
                if (board[r][c] === player) {
                    consecutive++;
                } else if (board[r][c] === null) {
                    if (consecutive > 0 && gaps === 0) {
                        gaps++;
                        spaces++;
                    } else {
                        endReached = true;
                        break;
                    }
                } else {
                    endReached = true;
                    break;
                }
                r += dRow;
                c += dCol;
                spaces++;
            }
            
            if (!endReached && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === null) {
                openEnds++;
            }
            
            const opponent = player === 'black' ? 'white' : 'black';
            let blocked1 = (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || 
                           (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === opponent));
            
            // Check negative direction
            r = row - dRow;
            c = col - dCol;
            spaces = 0;
            endReached = false;
            
            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && spaces < 5) {
                if (board[r][c] === player) {
                    consecutive++;
                } else if (board[r][c] === null) {
                    if (consecutive > 0 && gaps === 0) {
                        gaps++;
                        spaces++;
                    } else {
                        endReached = true;
                        break;
                    }
                } else {
                    endReached = true;
                    break;
                }
                r -= dRow;
                c -= dCol;
                spaces++;
            }
            
            if (!endReached && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === null) {
                openEnds++;
            }
            
            let blocked2 = (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || 
                           (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === opponent));
            
            // If blocked rule is ON and both ends are blocked, this pattern is worthless
            const bothEndsBlocked = blocked1 && blocked2;
            if (blockedRule && bothEndsBlocked) {
                openEnds = 0; // Force pattern to be worthless
            }
            
            return {consecutive, openEnds, gaps, bothEndsBlocked};
        }

        // Get score for a pattern
        function getPatternScore(pattern) {
            const {consecutive, openEnds, gaps, bothEndsBlocked} = pattern;
            const total = consecutive + 1; // +1 for the move we're evaluating
            
            // If blocked rule is ON and both ends are blocked, pattern is worthless
            if (blockedRule && bothEndsBlocked && total < 5) {
                return 0; // Can't win with this pattern
            }
            
            if (total >= 5) {
                // Even if blocked, 5+ wins (unless blocked rule prevents it)
                if (blockedRule && bothEndsBlocked) {
                    return 0; // Doesn't count as win
                }
                return PATTERNS.FIVE;
            }
            
            if (total === 4) {
                if (openEnds === 2) return PATTERNS.OPEN_FOUR;
                if (openEnds === 1) return PATTERNS.FOUR;
                if (openEnds === 0) return 0; // Blocked on both ends
            }
            if (total === 3) {
                if (openEnds === 2) return PATTERNS.OPEN_THREE;
                if (openEnds === 1) return PATTERNS.THREE;
                if (openEnds === 0) return 0; // Blocked on both ends
            }
            if (total === 2) {
                if (openEnds === 2) return PATTERNS.OPEN_TWO;
                if (openEnds === 1) return PATTERNS.TWO;
                if (openEnds === 0) return 0; // Blocked on both ends
            }
            if (total === 1 && openEnds > 0) return PATTERNS.ONE;
            
            return 0;
        }

        // Count consecutive stones in one direction
        function countStones(row, col, dRow, dCol, player) {
            let count = 0;
            let r = row + dRow;
            let c = col + dCol;
            
            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
                count++;
                r += dRow;
                c += dCol;
            }
            
            return count;
        }

        // Check if the line is blocked at this end
        function isBlocked(row, col, dRow, dCol, count, player) {
            const r = row + dRow * (count + 1);
            const c = col + dCol * (count + 1);
            
            // If out of bounds, consider it not blocked (open end)
            if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
                return false;
            }
            
            // If the next cell has opponent's stone, it's blocked
            const opponent = player === 'black' ? 'white' : 'black';
            return board[r][c] === opponent;
        }

        // Check if board is full
        function isBoardFull() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === null) return false;
                }
            }
            return true;
        }

        // Update UI elements
        function updateUI() {
            const indicator = document.getElementById('playerIndicator');
            const text = document.getElementById('playerText');
            
            indicator.className = `player-indicator ${currentPlayer}`;
            
            if (gameMode === 'pvb') {
                if (currentPlayer === botColor) {
                    text.textContent = `Bot's Turn (${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)})`;
                } else {
                    text.textContent = `Your Turn (${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)})`;
                }
            } else {
                text.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn`;
            }
            
            if (!gameOver) {
                document.getElementById('message').textContent = '';
                document.getElementById('message').classList.remove('win-message');
            }
        }

        // Toggle blocked rule
        function toggleBlockedRule() {
            blockedRule = !blockedRule;
            const btn = document.getElementById('blockedRuleBtn');
            const info = document.getElementById('variantInfo');
            
            btn.innerHTML = blockedRule 
                ? '<span class="rule-icon"></span><span class="rule-text">Blocked Rule: <strong>ON</strong></span>'
                : '<span class="rule-icon"></span><span class="rule-text">Blocked Rule: <strong>OFF</strong></span>';
            
            info.textContent = blockedRule ? 'Blocked lines don\'t count as wins' : 'Blocked lines can win';
            
            // Update threats when blocked rule changes
            updateThreats();
            
            // If it's bot's turn and game is in progress, bot should reconsider
            if (gameMode === 'pvb' && currentPlayer === botColor && !gameOver && !botThinking) {
                // Bot reconsidering due to rule change
            }
        }

        // Toggle threat alert
        function toggleThreatAlert() {
            threatAlert = !threatAlert;
            const btn = document.getElementById('threatAlertBtn');
            
            btn.innerHTML = threatAlert
                ? '<span class="rule-icon"></span><span class="rule-text">Threat Alert: <strong>ON</strong></span>'
                : '<span class="rule-icon"></span><span class="rule-text">Threat Alert: <strong>OFF</strong></span>';
            
            // Update threat display
            updateThreats();
        }

        // Bead customization
        let currentBeadSet = 'classic';
        // Board customization
        let currentBoardStyle = 'classic';
        
        // Theme presets
        // Set bead set programmatically (without event)
        function setBeadSetProgrammatic(setName) {
            currentBeadSet = setName;
            
            // Update active button
            document.querySelectorAll('.bead-set-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-set') === setName) {
                    btn.classList.add('active');
                }
            });
            
            // Apply bead set to all existing stones
            applyBeadSet();
            
            // Update all hover shadows
            updateAllHoverShadows();
        }

        // Set board style programmatically (without event)
        function setBoardStyleProgrammatic(style) {
            currentBoardStyle = style;
            const board = document.querySelector('.board');
            
            // Remove all board style classes (but keep the base 'board' class)
            const boardStyleClasses = ['classic', 'dark', 'bamboo', 'marble', 'stone', 'neon', 'glass', 'metal', 'space', 'paper', 'cherry', 'crystal'];
            boardStyleClasses.forEach(styleClass => {
                board.classList.remove(`board-${styleClass}`);
            });
            
            // Add new board style class
            board.classList.add(`board-${style}`);
            
            // Update active button
            document.querySelectorAll('.board-style-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-style') === style) {
                    btn.classList.add('active');
                }
            });
        }

        // Set board style
        function setBoardStyle(style, btnElement) {
            currentBoardStyle = style;
            const board = document.querySelector('.board');
            
            // Remove all board style classes (but keep the base 'board' class)
            const boardStyleClasses = ['classic', 'dark', 'bamboo', 'marble', 'stone', 'neon', 'glass', 'metal', 'space', 'paper', 'cherry', 'crystal'];
            boardStyleClasses.forEach(styleClass => {
                board.classList.remove(`board-${styleClass}`);
            });
            
            // Add new board style class
            board.classList.add(`board-${style}`);
            
            // Update active button
            document.querySelectorAll('.board-style-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            // Reapply bead set to maintain crystal shapes if using crystal stones
            if (currentBeadSet === 'crystal') {
                applyBeadSet();
            }
        }

        // Set bead set
        function setBeadSet(setName, btnElement) {
            currentBeadSet = setName;
            
            // Update active button
            document.querySelectorAll('.bead-set-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            // Apply bead set to all existing stones
            applyBeadSet();
            
            // Update all hover shadows
            updateAllHoverShadows();
        }

        function applyBeadSet() {
            document.querySelectorAll('.stone').forEach(stone => {
                // Remove all bead set classes
                stone.className = stone.className.replace(/stone-(classic|flat|neon|marble|glossy|glass|crystal|metal|gem|plasma|space|paper|wood|ceramic)/g, '');
                
                // Add new bead set class
                stone.classList.add(`stone-${currentBeadSet}`);
                
                // Apply random crystal shape if switching to crystal
                if (currentBeadSet === 'crystal') {
                    const randomShape = generateRandomCrystalShape();
                    stone.style.clipPath = randomShape;
                } else {
                    // Clear clip-path for non-crystal styles
                    stone.style.clipPath = '';
                }
            });
        }

        // Update all hover shadows to match current bead set
        function updateAllHoverShadows() {
            document.querySelectorAll('.hover-shadow').forEach(shadow => {
                // Remove all shadow style classes
                shadow.className = shadow.className.replace(/shadow-(classic|flat|neon|marble|glossy|glass|crystal|metal|gem|plasma|space|paper|wood|ceramic)/g, '');
                
                // Preserve black/white class and add new shadow style
                const colorClass = shadow.classList.contains('black') ? 'black' : (shadow.classList.contains('white') ? 'white' : '');
                shadow.className = `hover-shadow ${colorClass} shadow-${currentBeadSet}`.trim();
            });
        }

        // Generate random crystal shape with irregular facets
        function generateRandomCrystalShape() {
            const numPoints = 12; // 12-point polygon for crystal
            const points = [];
            
            // Generate random points around a circle with variation
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI; // Full circle in radians
                const radiusVariation = 35 + Math.random() * 30; // Random radius between 35-65%
                const angleVariation = angle + (Math.random() - 0.5) * 0.3; // Small angle variation in radians
                
                // Convert to percentage coordinates
                const x = 50 + radiusVariation * Math.cos(angleVariation);
                const y = 50 + radiusVariation * Math.sin(angleVariation);
                
                points.push(`${x.toFixed(1)}% ${y.toFixed(1)}%`);
            }
            
            return `polygon(${points.join(', ')})`;
        }

        // Update custom colors
        // Toggle settings panel
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // Set theme
        let currentTheme = 'midnight';

        // Toggle game mode
        function toggleGameMode() {
            gameMode = gameMode === 'pvp' ? 'pvb' : 'pvp';
            const btn = document.getElementById('gameModeBtn');
            const botSettingsSection = document.getElementById('botSettingsSection');
            
            if (gameMode === 'pvb') {
                btn.innerHTML = '<span class="mode-icon"></span><span class="mode-text">Player vs Bot</span>';
                botSettingsSection.style.display = 'block';
                firstBotGame = true;
            } else {
                btn.innerHTML = '<span class="mode-icon"></span><span class="mode-text">Player vs Player</span>';
                botSettingsSection.style.display = 'none';
            }
            
            // Reset game when toggling game mode
            resetGame();
        }

        // Update bot settings from UI
        function updateBotSettings() {
            botLevel = document.getElementById('botLevel').value;
            botStylePreference = document.getElementById('botStyleSelect').value;
        }

        // Reset the game
        function resetGame() {
            initGame();
        }

        // Submit score to leaderboard
        function submitScore() {
            if (!lastGameResult) {
                return;
            }

            let playerName = document.getElementById('playerNameInput').value.trim();
            if (!playerName) {
                playerName = 'Anonymous';
            }

            // Save to global leaderboard in localStorage
            try {
                // Get existing scores
                let gomokuScores = [];
                const existingData = localStorage.getItem('gomokuScores');
                if (existingData) {
                    gomokuScores = JSON.parse(existingData);
                }

                // Add new score (each win is 1 point)
                gomokuScores.push({
                    name: playerName,
                    score: 1,
                    date: lastGameResult.date
                });

                // Sort by score (descending), then by date (most recent first)
                gomokuScores.sort((a, b) => {
                    if (b.score !== a.score) {
                        return b.score - a.score;
                    }
                    return new Date(b.date) - new Date(a.date);
                });

                // Keep only top 100 scores
                gomokuScores = gomokuScores.slice(0, 100);

                // Save back to localStorage
                localStorage.setItem('gomokuScores', JSON.stringify(gomokuScores));
            } catch (e) {
                console.error('Failed to save score to localStorage:', e);
            }

            // Hide name input modal
            document.getElementById('modalOverlay').classList.remove('show');
            document.getElementById('nameInputModal').classList.remove('show');
        }

        // Load sound preferences from localStorage
        loadSoundPreferences();

        // Start the game
        initGame();
    </script>
</body>
</html>